%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\newcommand{\Unicode}[1]{\mbox{$\backslash$u{#1}}}
\newcommand{\UnicodeRange}[2]{\mbox{$\backslash$u{#1}-$\backslash$u{#2}}}

\chapter{Lexical Syntax \& Analysis}
\label{sec:lexical-analysis}

\minitoc

Gear programs are written using the Unicode character set; Unicode supplementary characters are supported as well. Gear programs are preferably encoded with the UTF-8 character encoding. While every Unicode character is supported, usage of Unicode escapes is encouraged, since fonts that IDEs and text editors might use may not support the full Unicode character set.

Grammar of lexical tokens is given in the following sections. These tokens are then used as terminal symbols of the semantical grammar. 

To construct tokens, characters are distinguished according to the rules defined in the following sections. Various combination of different Unicode character classes can also build up tokens, and later on, parts of different higher syntax forms. 

% Unicode overview with lists: http://www.fileformat.info/info/unicode/category/index.htm 

\newpage






\section{Identifiers \& Keywords}
\label{sec:identifiers}
\label{sec:keywords}

\syntax\begin{lstlisting}[deletekeywords={of,and,class,for}]
digit_char      ::= '0' $\ldots$ '9'
letter_char     ::= ? Unicode char of classes Lu, Ll, Lt, Lo, 
                    Lm and Nl ?
connecting_char ::= ? Unicode char of class Pc ?
combining_char  ::= ? Unicode char of classes Mn and Mc ?
formatting_char ::= ? Unicode char of class Cf ?
lower           ::= ? Unicode char of class Ll ?
upper           ::= (letter_char - lower) 
                  | ? Dollar sign ? | '§' | '_'

var_id   ::= lower id_rest
plain_id ::= upper id_rest
           | var_id
id       ::= ['@' | '@@'] (plain_id
             | '`' plain_id '`'
             | '``' {any_id}+ '``')
           | '`' op_id '`'
id_char  ::= letter_char
           | digit_char
           | connecting_char
           | combining_char
           | formatting_char
           | '+' | '-' | '/' | '_'
id_rest  ::= {id_char} ['?' | '!' | ''']
any_id   ::= ? any Unicode char except for backquote: '`' ?
\end{lstlisting}

There are more kinds of identifiers. An identifier can start with a letter, which can be followed by an arbitrary sequence of letters, digits, underscores and operator characters. The identifier may be prefixed with one or two {\em at} ``\code{@}'' signs, creating an instance variable or a class object variable identifier, respectively. These forms are called {\em plain identifiers}. An identifier may also start with an operator character, followed by arbitrary sequence of operator characters, forming operator identifiers, which can only be used in expressions that directly involve operators (\sref{sec:prefix-infix-ops}). 

An identifier may also be formed by an identifier between back-quotes (``\lstinline!$\,$`$\,$!''), to resolve possible name clashes with Gear keywords, and to allow to identify operators. An identifier may also be enclosed in double back-quotes (``\lstinline!$\,$``$\,$!''), where any unicode character may appear, except for another back-quote. Instance variable names and class instance variable names never clash with a keyword name, since these are distinguished by the preceding ~``\lstinline!@!''~ and ~``\lstinline!@@!''~ respectively. 

Gear programs are parsed greedily, so that a longest match rule applies. Letters from the syntax may be any Unicode letters, but English alphabet letters are recommended, along with English\footnote{English, not mistakes.} names.

The ``\lstinline[mathescape=false]!$!'' character is reserved. 

A set of identifiers is reserved for language features instead of for user identifiers. However, unlike in some other languages, keywords are not being recognized inside of paths, except for a few specific cases.

The following names are the reserved words. Identifiers that match any of the specified reserved word carry the extra property of being a possible keyword, which is used in syntactic grammar. 

\syntax\begin{lstlisting}
Identifier_Keyword ::= ? id, one of: ?
abstract      advice        advice-execution            after
alias         and           annotation    arguments     around
as            aspect        assert        atomic        attribute
begin         before        bitfield      break         broken
case          catch         class         clone         cloned
constant      constraint    constructor   declare       def
delta         destructor    digits        dispatch      do
done          eager         else          elsif         end
ensure        enum          execution     exhausted     extends
final         for           for-some      foreign       function
functor       get           goto          handler       if
immutable     implements    implicit      in            include
interface     intersection  invariant     invoke        is
joinpoint     label         lazy          let           loop
macro         match         measure       member        memoize
message       method        module        monitored     multi
mutable       native        next          nil           no
not           object        of            opaque        operator
optional      or            origin        otherwise     outer
override      parallel      per-self      per-target    pointcut
pragma        prefer        prepend       private       property
protected     protocol      public        pure          raise
raiseable     raising       range         rec           recursive
record        redo          ref           refine        refinement
release       reraise       rescue        retain        rethrow
retry         return        returning     requires      reverse
sealed        self          set           seq           sig
skip          soft          step          struct        super
switch        synchronized  tailcall      target        then
this          throw         throwable     throwing      to
trait         transparent   type          undefined     unless
unowned       until         union         upgrade       use
val           var           variant       yes           weak
when          while         with          xor           yield
yielding
\end{lstlisting}

Not every reserved word is a keyword in every context, this behavior will be further explained by syntax definitions. For example, the bitfield reserved word is only recognized as a keyword inside an enumeration definition context, in a specific place. In case of ambiguous syntax views of a sequence of source tokens, the ones that include keywords are preferred.\footnote{This may happen with selection sequences that would include e.g. ~\lstinline!prefix.type!. To treat \code{type} as another selection, enclose it in backticks: ~\lstinline[deletekeywords={type}]!prefix.`type`!.} In any case, reserved words enclosed in backticks (``\lstinline!$\,$`$\,$!'') are not treated as keywords. 





\section{Symbolic Keywords}
\label{sec:symbolic-keywords}

\syntax\begin{lstlisting}[deletekeywords={of}]
Symbolic_Keyword ::= ? one of: ?
let!  yield!  return!  as?  as!  is!  not!
|  .  .?  .!  :  (  )  [  ]  <  >  >:  <:  :>
%[|  |]  %[  %(  {  %{  }  %/  /
'  #  ..  ..<  ...  :=  ==  /== ;  ;;  ->  
=>  =>>  *  **  &
_  @  <@  @>  <@@  @@>
\end{lstlisting}

Symbolic or partially symbolic character sequences can be treated as keywords, if a lexical or syntactic grammars specifies that. Some lexical grammars extend some of these sequences with ``flags''. 





\section{Symbolic Operators}
\label{sec:symbolic-operators}

\syntax\begin{lstlisting}[deletekeywords={of,and}]
op_id       ::= Symbolic_Op
Symbolic_Op ::= {op_char}+
              | '`' {op_char}+ '`'
op_char     ::= ? Unicode char of classes Sm and So ?
\end{lstlisting}

Symbolic operators are sequences of characters as shown above, except where the sequence of characters is a symbolic keyword (\sref{sec:symbolic-keywords}) and is used by the corresponding grammar as such.\footnote{In another words, symbolic keywords have a precedence over symbolic operators, if a grammar would be otherwise ambiguous.}





\section{Newline Characters}
\label{sec:newlinecharacters}

\syntax\begin{lstlisting}
nl   ::= (* Line Feed, LF; Multics, Unix, Unix-like... *)
         ? $\Unicode{000A}$ ? 
         
         (* Carriage Return, CR; Mac OS 9-, ZX Spectrum... *)
       | ? $\Unicode{000D}$ ? 
       
         (* CR+LF; Windows, DOS, OS/2, Symbian OS... *)
       | ? $\Unicode{000D}$ $\Unicode{000A}$ ?
       
         (* LF+CR; RISC OS... *)
       | ? $\Unicode{000A}$ $\Unicode{000D}$ ?
       
         (* Unicode conformance *)
       | ? $\Unicode{000B}$ ? (* Vertical Tab, VT *)
       | ? $\Unicode{000C}$ ? (* Form Feed, FF *)
       | ? $\Unicode{0085}$ ? (* NExt Line, NEL *)
       | ? $\Unicode{2028}$ ? (* Line Separator, LS *)
       | ? $\Unicode{2029}$ ? (* Paragraph Separator, PS *)
       
semi ::= {nl}+ | ';' {nl}
tend ::= ';;'
\end{lstlisting}

Gear is a line-oriented language, in which statements are expressions and may be terminated by newlines, as well as by semi-colon operator. A newline in a Gear source file is treated as the special separator token \lstinline@nl@ if the following criteria are satisfied:

\begin{enumerate}
  \item The token immediately preceding the newline can terminate an expression.
  \item The token immediately following the newline can begin a new expression. 
\end{enumerate}

In interactive environment, top-level expressions are ended by entering the ``\code{;;}'' sequence of tokens (\code{tend}). 

If the token immediately preceding the newline can not terminate an expression and is followed by more than one newline, Gear still sees that as only a one significant newline, to prevent any confusion.

The grammar rules contain productions where the optional newline (``\code{[nl]}'') is present, in which case it obviously does not end any expression. 






\section{Literals}
\label{sec:literals}

There are literals for numbers (including integer, floating point and complex), characters, booleans, strings, symbols, regular expressions and collections (including tuples, lists, dictionaries and bags). 

\syntax\begin{lstlisting}
Literal ::= integer_literal
	      | floating_point_literal
	      | complex_literal
	      | rational_literal
	      | character_literal
	      | boolean_literal
	      | unit_literal
	      | string_literal
	      | symbol_literal
	      | regular_expression_literal
	      | Collection_Literal
	      | 'nil'
	      | 'undefined'
\end{lstlisting}






\subsection{Integer Literals}\label{sec:integerliterals}

\syntax\begin{lstlisting}
integer_literal ::= sign (
                    decimal_numeral
                  | hex_numeral
                  | octal_numeral
                  | binary_numeral)
decimal_numeral ::= digit {['_'] digit}
hex_numeral     ::= hex_prefix | hex_digit {['_'] hex_digit}
digit           ::= '0' | $\cdots$ | '9'
hex_digit       ::= '0' | $\cdots$ | '9' | 'a' | $\cdots$ | 'f'
octal_numeral   ::= oct_prefix oct_digit {'_' oct_digit}
oct_digit       ::= '0' | $\cdots$ | '7'
binary_numeral  ::= bin_prefix bin_digit {['_'] bin_digit}
bin_digit       ::= '0' | '1'
hex_prefix      ::= '0x'
bin_prefix      ::= '0b'
oct_prefix      ::= '0o'
sign            ::= ['+' | '-'] | ()
\end{lstlisting}

Integers are usually of type \lstinline@Number@, which is a class cluster of all types that can represent numbers. Unlike Java, Gear supports both signed and unsigned integral types directly. Usually integer literals that are obviously unsigned integers are automatically represented internally by a class that stores the integer unsigned, like \lstinline@Integer_64_Unsigned@, but this is implementation-defined. Math operations on numbers are handled internally in such a way that the user doesn't need to worry about the actual types of the numbers — when an integer overflow would occur, the result is stored in a larger container type, or maybe even in a smaller container if fit. Expected type is always respected in any case. 

Underscores ``\code{_}'' are allowed between digits for readability, but are otherwise ignored. Decimal integer literals can begin with leading zeros ``\code{0}'', but those zeros are likewise ignored. 

Integral members of the \lstinline@Number@ class cluster include the following container types. It is implementation-defined how numbers are actually stored and represented internally by the VM -- the language itself does not care, so long as types are respected. 

\begin{enumerate}

  \item \lstinline@Integer_8@ ($-2^{7}$ to $2^{7}-1$), alias \lstinline@Byte@

  \item \lstinline@Integer_8_Unsigned@ ($0$ to $2^{8}$), alias \lstinline@Byte_Unsigned@

  \item \lstinline@Integer_16@ ($-2^{15}$ to $2^{15}-1$), alias \lstinline@Short@

  \item \lstinline@Integer_16_Unsigned@ ($0$ to $2^{16}$), alias \lstinline@Short_Unsigned@

  \item \lstinline@Integer_32@ ($-2^{31}$ to $2^{31}-1$)

  \item \lstinline@Integer_32_Unsigned@ ($0$ to $2^{32}$)

  \item \lstinline@Integer_64@ ($-2^{63}$ to $2^{63}-1$), alias \lstinline@Long@

  \item \lstinline@Integer_64_Unsigned@ ($0$ to $2^{64}$), alias \lstinline@Long_Unsigned@

  \item \lstinline@Integer_128@ ($-2^{127}$ to $2^{127}-1$), alias \lstinline@Cent@

  \item \lstinline@Integer_128_Unsigned@ ($0$ to $2^{128}$), alias \lstinline@Cent_Unsigned@

  \item \lstinline@Decimal@ ($-\infty$ to $\infty$)

  \item \lstinline@Decimal_Unsigned@ ($0$ to $\infty$)

\end{enumerate}

The special \lstinline@Decimal@ \& \lstinline@Decimal_Unsigned@ container types are also for storing arbitrary precision floating point numbers. All the container types are constants defined in the \lstinline@Number@ class and can be imported into scope if needed. 

Moreover, a helper type \lstinline@Number.Unsigned@ exists, which can be used for type casting in cases where an originally signed number needs to be treated as unsigned. 

Weak conformance applies to the inner members of \lstinline@Number@ class. 

For use with range types, \lstinline@Number.Integer@ and \lstinline@Number.Integer_Unsigned@ exist, to allow constraining of the range types to integral numbers. The class cluster types may also be viewed as range types (or constrained types), utilizing their range of values as bounds (or constraints). 






\subsection{Floating \& Fixed Point Literals}
\label{sec:floatliterals}
\label{sec:fixedpointliterals}

\syntax\begin{lstlisting}
float_literal   ::= sign decimal_numeral '.' decimal_numeral
                    [exponent_part_e] [float_type]
                  | sign decimal_numeral exponent_part_e [float_type]
                  | sign decimal_numeral float_type
                  | sign hex_prefix hex_numeral '.' hex_numeral 
                    [exponent_part_p [float_type] 
                     | hex_exp float_type]
                  | sign hex_prefix hex_numeral exponent_part_p 
                    [float_type]
                  | sign hex_prefix hex_numeral hex_exp float_type
                  | sign oct_prefix octal_numeral '.' octal_numeral 
                    [exponent_part_e] [float_type]
                  | sign oct_prefix octal_numeral exponent_part_e 
                    [float_type]
                  | sign oct_prefix octal_numeral float_type
                  | sign bin_prefix binary_numeral '.' binary_numeral 
                    [exponent_part_e] [float_type]
                  | sign bin_prefix binary_numeral exponent_part_e 
                    [float_type]
                  | sign bin_prefix binary_numeral float_type
exponent_part_e ::= int_exp sign decimal_numeral
exponent_part_p ::= hex_exp sign decimal_numeral
int_exp         ::= 'e'
hex_exp         ::= 'p'
float_type      ::= 'h' | 'f' | 'd' | 'q' | 'df'
\end{lstlisting}

Floating point and fixed point literals are of type \lstinline@Number@ as well as integral literals, and have fewer container types. Compiler infers the precision automatically, unless the \lstinline@float_type@ part is present. Literals that have \lstinline@float_type@ of ``\code{df}'' are ({\em d}ecimal) {\em f}ixed point literals. Also, floating point literals that are impossible to represent in binary form accurately are implicitly inferred to be fixed point literals, unless specifically converted to a floating point type or using a \code{float_type} of \code{h}, \code{f} or \code{d}. From \code{Number}'s user perspective, this is only an implementation detail, and the VM is not required to store floating or fixed point values in any specific representation other than that with the required precision and properties. 

\begin{enumerate}

  \item \lstinline@Float_16@ (IEEE 754-2008 16-bit precision), alias \lstinline@Half_Float@. 
  
  \item \lstinline@Float_32@ (IEEE 754-2008 32-bit precision), alias \lstinline@Float@. 

  \item \lstinline@Float_64@ (IEEE 754-2008 64-bit precision), alias \lstinline@Double@.

  \item \lstinline@Float_128@ (IEEE 754-2008 128-bit precision), alias \lstinline@Quadruple@.

  \item \lstinline@Decimal@ ($-\infty$ to $\infty$).

  \item \lstinline@Decimal_Unsigned@ ($0$ to $\infty$).

\end{enumerate}

Letters in the exponent type, hexadecimal numbers and float type literals have to be lower-case in Gear sources, but functions that parse floating point numbers do support them being upper-case for compatibility. 





\subsection{Not A Number}
\label{sec:nan}

A member named \code{Not_a_Number} exists in the class cluster \code{Number}, with an alias of \code{NaN}, to denote results of operations on numbers that are not numbers, e.g., result of division by zero. There is no literal for this special value in Gear. 





\subsection{Rational Number Literals}
\label{sec:rationalliterals}

\syntax\begin{lstlisting}
real_number_literal ::= integer_literal | float_literal
rat_suffix_literal  ::= real_number_literal 'r'
rational_literal    ::= real_number_literal 
                        ['/' rat_suffix_literal]
\end{lstlisting}

Rational number literals are of type \code{Number}, and have a container type \code{Number.Rational}, which has further methods of creating instances of itself. There are also methods in \code{Number}, such as \code{//}, which results in a rational number. Rational numbers have sort of increased accuracy of operations, especially when component types are integral types. 

\example Some literal notations and methods that result in rational numbers. 
\begin{lstlisting}
val a := 1 / 3r
val b := 1 // 3
val c := Rational(1, 3)
\end{lstlisting}







\subsection{Imaginary Number Literals}
\label{sec:imaginaryliterals}

\syntax\begin{lstlisting}
imaginary_literal   ::= rational_literal 'i'
complex_literal     ::= [rational_literal ('+' | '-') ]
                        imaginary_literal
	                  | imaginary_literal ('+' | '-') 
	                    rational_literal
number_literal      ::= imaginary_literal
	                  | complex_literal
	                  | rational_literal
\end{lstlisting}

Imaginary number literals are of type \code{Number}, and have a basically a single container type: \code{Number.Complex}. The syntax requirement here is whitespace around the ``\code{+}'' and ``\code{+}'' signs, separating the real part from the imaginary part. Newlines as whitespace have the same effect as defined for cases where the sign could be considered to be an operator (\sref{sec:newlinecharacters}).





\subsection{Units of Measure}
\label{sec:unitsofmeasuresyntax}

Gear has an addition to number handling, called {\em units of measure} (\sref{sec:units-of-measure}). Number instances can be annotated with a unit of measure to ensure correctness of arithmetic operations. 

\syntax\begin{lstlisting}
annotated_number ::= number_literal '[<' uom_expr '>]'
uom_expr         ::= Unit_Conv {',' Unit_Conv}
\end{lstlisting}

\example Some number literals annotated with units of measure:
\begin{lstlisting}
var min_motorway_speed := 90 [<km/hour>]
(* in the end, same as: *)
var distance := 90 [<km>]
var time := 1 [<hour>]
min_motorway_speed := distance // time
\end{lstlisting}






\subsection{Character Literals}
\label{sec:characterliterals}

\syntax\begin{lstlisting}
printable_char    ::= ? all visible and printable UTF-8 characters ? 
character_literal ::= '%'' (printable_char | char_escape_seq) '''
\end{lstlisting}

Character literals are of type \code{Character}, and are internally similar to strings (\sref{sec:stringliterals}) of length of 1 character. 

Character escape sequences are used in strings as well, and are defined as follows: 

\syntax\begin{lstlisting}[language=]
char_escape_seq ::= 
      '\'' (* Literal single-quote: ' *)
    | '\"' (* Literal double-quote: " *)
    | '\?' (* Literal question mark: ? *)
    | '\\' (* Literal backslash: \ *)
    | '\#' (* Literal hash: # *)
    | '\{' (* Literal left curly brace: { *)
    | '\}' (* Literal right curly brace: } *)
    | '\0' (* Binary zero (NUL, U+0000) *)
    | '\a' (* BEL (alarm) character (U+0007) *)
    | '\b' (* Backspace (U+0008) *)
    | '\f' (* Form feed (FF, U+000C) *)
    | '\n' (* End-of-line (U+000A) *)
    | '\r' (* Carriage return (U+000D) *)
    | '\t' (* Horizontal tab (U+0007) *)
    | '\v' (* Vertical tab (U+000B) *)
    | '\x$nn$' (* Byte value in hexadecimal *) 
    | '\$n$' (* Byte value in octal *)
    | '\$nn$' (* Byte value in octal *)
    | '\$nnn$' (* Byte value in octal *)
    | '\u$nnnn$' (* Unicode character U+$nnnn$, hex digits *)
    | '\U$nnnnnnnn$' (* Unicode character U+$nnnnnnnn$, hex digits *)
    | '\' named_char ';' (* Named character entity *)
\end{lstlisting}

The named character reference (\code{named_char}) is defined by HTML5 (\url{http://www.w3.org/TR/html5/syntax.html#named-character-references});

The octal byte values are consumed with the longest match. 






\subsection{Boolean Literals}
\label{sec:booleanliterals}

\syntax\begin{lstlisting}
boolean_literal ::= 'yes' | 'no'
\end{lstlisting}

Both literals are members of type \lstinline@Boolean@. The \lstinline@no@ literal has also a special behavior when being compared to \lstinline@nil@: \lstinline@no@ equals to \lstinline@nil@, while not actually being \lstinline@nil@. Identity equality is indeed different, and \code{no} does not match in pattern matching (\sref{sec:pattern-matching}) as \code{nil} and vice versa. The implication is that both \lstinline@nil@ and \lstinline@no@ are false conditions in \lstinline@if@-expressions. 




\subsection{Unit Literal}
\label{sec:unit-literal}

\syntax\begin{lstlisting}
unit_literal ::= '()'
\end{lstlisting}

Unit literal is of the type \code{Unit} (also known as \code{Gear/Language.Unit}, and has alias of \code{Gear/Language.Tuple_0}).





\subsection{String Literals}
\label{sec:stringliterals}

\syntax\begin{lstlisting}
string_literal      ::= int_string_literal
                      | raw_string_literal
                      | verbatim_string
int_string_literal  ::= '"' {int_string_element} '"'
                      | '%'  [str_flags] '"' {int_string_element} '"'
raw_string_literal  ::= '%r' [str_flags] '"' {string_element} '"'
verbatim_string     ::= '"""' {printable_char} '"""'
string_element      ::= printable_char | char_escape_seq
int_string_element  ::= string_element | interpolated_expr
interpolated_expr   ::= '#{' Expr '}'
str_flags           ::= 'm' | 'i'
\end{lstlisting}

String literals are members of the type ~\lstinline@String@. Double quotes in interpolable string literals have to be escaped (\lstinline@\"@).

String literals appear in multiple forms:
\begin{itemize}
  \item {\em Raw strings} are of the form ~\lstinline!%r$f$"$s$"!. There are no interpolated expressions. If a sequence of string elements appears to be an interpolated expression, it is not, and is instead treated as a part of the raw string as it is. Escape sequences are evaluated. 
  \item {\em Interpolable strings} are of the forms ~\lstinline!"$s$"!~ and ~\lstinline!%$f$"$s$"!. Interpolated expressions can appear there, if its introducing character is not escaped by an odd number of backslashes. Interpolated expressions are evaluated, converted to \code{String_Like} and their result inserted at each place in the string where they appear, safely. 
  \item {\em Verbatim strings} are of the form ~\lstinline!"""$s$"""!. Escape sequences and interpolated expressions are not evaluated, also there is thus no way to escape the delimiter (\lstinline!"""!) inside it. Verbatim strings are immutable, and can be made mutable by use of appropriate methods. 
  \item {\em Immutable strings} are all strings that do not carry the flag \code{m} (\textbf{m}utable). The flag \code{i} (\textbf{i}mmutable) is redundant in this manner, and is only provided for completeness. 
  \item {\em Mutable strings} are only those strings that carry the flag \code{m}. Immutable strings may be converted to mutable strings and vice versa by use of appropriate methods. 
\end{itemize}

In each form, $s$ is the string content, and $f$ are string flags, as defined. 

In each form, literal newlines do not need to be escaped. Newlines may still be inserted into single-line string literals. Having escaped newlines appearing in a multi-line string is suspicious. 





\subsection{Symbol Literals}
\label{sec:symbolliterals}

\syntax\begin{lstlisting}
symbol_literal       ::= simple_symbol | quoted_symbol
simple_symbol        ::= ':' plain_id
quoted_symbol        ::= ':"' {int_string_element} '"'
\end{lstlisting}

Symbol literals are members of the type \lstinline@Symbol@. They differ from \nameref{sec:stringliterals} in the way runtime handles them: while there may be multiple instances of the same string, there is always up to one instance of the same symbol. Unlike in Ruby, they do get released from memory when no code references to them anymore, so their object id (sometimes) varies with time. Gear does not require their ids to be constant in time. 









\subsection{Regular Expression Literals}\label{sec:regexpliterals}

\syntax\begin{lstlisting}
regexp_literal     ::= '%/' regexp_content_int '/' [regexp_flags]
	                 | '%r/' regexp_content_int '/' [regexp_flags]
	                 | '%r#' regexp_content '#' [regexp_flags]
	                 | '%r~' regexp_content_int '~' [regexp_flags]
regexp_content_int ::= regexp_element_int {regexp_element_int}
regexp_element_int ::= string_element | int_string_element
regexp_content     ::= string_element {string_element}
regexp_flags       ::= printable_char {printable_char}
\end{lstlisting}

Regular expression literals are members of the type \lstinline@Regular_Expression@ with alias of \lstinline@Regexp@. 






\subsection{Collection Literals}\label{sec:collectionliterals}

Collection literals are paired syntax tokens and as such, they are a kind of parentheses in Gear sources. 

\syntax\begin{lstlisting}
Collection_Literal ::= Tuple_Literal
	                 | List_literal
	                 | Dictionary_Literal
	                 | Bag_Literal
Collection_Flags   ::= printable_char {printable_char}
CF                 ::= Collection_Flags
Tuple_Literal      ::= '(' [Exprs] ')'
Collection_Exprs   ::= Expr {semi Expr}
List_Literal       ::= '%' [CF] '['  [Collection_Exprs]  ']'
Array_Literal      ::= '%' [CF] '[|' [Collection_Exprs] '|]'
Dictionary_Literal ::= '%' [CF] '{'  [Collection_Exprs]  '}'
Bag_Literal        ::= '%' [CF] '('  [Collection_Exprs]  ')'
Dict_Exprs         ::= Dict_Expr {semi Dict_Expr}
Dict_Expr          ::= Simple_Expr1 '=>' Expr
	                 | id ':' Expr
\end{lstlisting}

Tuple literals are members of the \lstinline@Tuple@ type family. List literals are members of the \lstinline@List_Like@ type, usually \lstinline!Linked_List! with alias of \lstinline@List@. Array literals are members of the \lstinline!Array_Like! type, usually \lstinline!Array!. Dictionary literals are members of the \lstinline@Dictionary@ type with alias of \lstinline@Map@, usually \lstinline@Hash_Dictionary@ with alias of \lstinline@Hash_Map@. Bag literals are members of the \lstinline@Bag@ type, usually \lstinline@Hash_Bag@ or \lstinline@Hash_Set@. Collection flags may change the actual class of the literal, along with some other properties, described in the following text. 

List literal collection flags: 

\begin{enumerate}
  \item Flag \lstinline@i@ = \textbf{i}mmutable, makes the list frozen. 
  \item Flag \lstinline@l@ = double \textbf{l}inked, makes the list a member of \lstinline@Double_Linked_List@. 
  \item Flag \lstinline@w@ = \textbf{w}ords, the following expressions are treated as words, converted to strings for each word separated by whitespace.
\end{enumerate}

Array literal collection flags:

\begin{enumerate}
  \item Flag \lstinline@i@ = \textbf{i}mmutable, makes the array frozen.
  \item Flag \lstinline@w@ = \textbf{w}ords, the following expressions are treated as words, converted to strings for each word separated by whitespace. 
\end{enumerate}

Dictionary literals collection flags:

\begin{enumerate}
  \item Flag \lstinline@i@ = \textbf{i}mmutable, makes the dictionary frozen. 
  \item Flag \lstinline@l@ = \textbf{l}inked, makes the dictionary a member of \lstinline@Linked_Hash_Dictionary@ (also has alias \lstinline@Linked_Hash_Map@).
  \item Flag \lstinline@m@ = \textbf{m}ulti-map, the dictionary items are then either the items themselves, if there is only one for a particular key, or a set of items, if there is more than one item for a particular key. The dictionary is then a member of \lstinline@Multi_Hash_Dictionary@ (alias \lstinline@Multi_Hash_Map@) or \lstinline@Linked_Multi_Hash_Dictionary@ (alias \lstinline@Linked_Multi_Hash_Map@). 
\end{enumerate}

Bag literal collection flags:

\begin{enumerate}
  \item Flag \lstinline@i@ = \textbf{i}mmutable, makes the bag frozen. 
  \item Flag \lstinline@s@ = \textbf{s}et, the collection is a set instead of a bag (a specific bag, such that for each item, its tally is always $0$ or $1$, thus each item is in the collection up to once). 
  \item Flag \lstinline@l@ = \textbf{l}inked, makes the collection linked, so either a member of \lstinline@Linked_Hash_Bag@ in case of a regular bag, or \lstinline@Linked_Hash_Set@ in case of a set. 
\end{enumerate}

Linked collections have a predictable iteration order in case of bags and dictionaries, or are simply stored differently in case of lists. 

The type of elements of a collection is inferred from combination of the expected type of the whole literal, expected type of each element and type argument of the collection literal. 
\begin{itemize}
  \item If an expected type is given, its type arguments take precedence over types of elements. Elements may be subject to implicit conversions (\sref{sec:implicit-conversions}). This inference works with an implicit conversion from a builder type to the target collection type -- there must exists such a builder type that has a build method returning the type that is the expected type or a type that is convertible to the expected type.\footnote{If a custom type is used, it has to statically conform to one of the protocols that the particular collection requires, so that the matching type argument can be retrieved and used for the collection builder.} 
  \item If a type argument is present, it takes precedence over both types of elements and the expected type of the literal, which is then used to implicitly convert the whole parameterized collection type. 
  \item If the expected type is undefined and no type argument is given, then the elements type is inferred as the least upper bound of all expected types of each element. If no element is given, then \code{Any} is inferred.\footnote{\code{Any} is inferred so that the shortest type argument-less collection literal would be more useful than just allowing elements of type \code{Nothing}, for which just one instance exists.}
  \item If the collection literal is a dictionary, then the least upper bound is computed for key and value types independently.
\end{itemize}

\example The following lines show how type inference works with collection literals. 
\begin{lstlisting}
/* Linked_List[String] */
val a: List[String] := %[]
val b := %[][String]
val c := %["hello"; "world"]

/* Array[String] */
val a: Array[String] := %[||]
val b := %[||][String]
val c := %[|"hello"; "world"|]

/* Hash_Dictionary[String, String] */
val d: Hash_Dictionary[String, String] := %{}
val e := %{}[String, String]
val f := %{"hello" => "world"}

/* Hash_Dictionary[Symbol, String] */
val d: Hash_Dictionary[Symbol, String] := %{}
val e := %{}[Symbol, String]
val f := %{hello: "world"}

/* Hash_Bag[String] */
val g: Bag[String] := %()
val h := %()[String]
val i := %("hello"; "world")
\end{lstlisting}






\section{Whitespace \& Comments}
\label{sec:whitespacecomments}

Tokens may be separated by whitespace characters and/or comments. Comments come in two forms: 

A multi-line comment is a sequence of characters between \lstinline@(* and *)@. Multi-line comments may be nested. There is a whitespace (including newlines) required after \lstinline@(*@ and before \lstinline@*)@ in the outermost multi-line comment. 

A single-line comment in Gear is a multi-line comment, written all on one line. That's all. No special syntax for that. 

Documentation comments are multi-line comments that start with \lstinline@(*!@. A whitespace is required after the opening token. 

As a special case (not only) for UNIX-like systems that support the notation, the initial lines of source file that start with the sequence ``\lstinline@#!@'' are ignored. 

Whitespace tokens and comments are not discarded during lexical analysis, but instead after lexical filtering, by rules described in (\sref{sec:lexical-filtering}).





\section{Conditional Compilation}
\label{sec:conditional-compilation}

\syntax\begin{lstlisting}
Pragma           ::= If_Directive 
                   | Else_Directive 
                   | End_If_Directive 
If_Directive     ::= 'pragma' 'if' id {'.' id}
Else_Directive   ::= 'pragma' 'else'
End_If_Directive ::= 'pragma' 'end-if'
\end{lstlisting}

If an \code{If_Directive} token is matched during tokenization, text is recursively tokenized until a corresponding \code{Else_Directive} or \code{End_If_Directive}. If the compilation environment defines the associated identifier, the token stream includes the tokens between the \code{If_Directive} and the corresponding \code{Else_Directive} or \code{End_If_Directive}. Otherwise, the tokens are discarded. The converse applies to the tokens between a corresponding \code{Else_Directive} and \code{End_If_Directive}. These directives may be nested. 





\section{Hidden Tokens}
\label{sec:hidden-tokens}

Some hidden tokens are inserted by lexical filtering (\sref{sec:lexical-filtering}), or are used to replace existing tokens. 





