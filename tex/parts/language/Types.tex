%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\chapter{Types}

\minitoc

\newpage

\section{About Amlantis' Type System}

\grammar\begin{lstlisting}
Type_Expr
    ::= Function_Type [Quantification_Clauses]
      | Infix_Type [Quantification_Clauses]
      | Type_Pack_Expansion
      | Type_Context Type_Expr
      | Atomic_Type_Expr
Quantification_Clauses 
    ::= Quantification_Clause {'and' Quantification_Clause}
Quantification_Clause  
    ::= Existential_Clauses
      | Universal_Clauses
      | Given_Clauses
      | Type_Constraint_Clause
Given_Clauses
    ::= 'given' Simple_Type
      | 'given' '{' Given_Dcl {semi Given_Dcl} '}'
Tuple_of_Types 
    ::= Type_Expr {',' Type_Expr}
Type_Equation 
    ::= '=' Type_Expr
Type_Pack_Expansion 
    ::= '...' Type_Expr
Atomic_Type_Expr
    ::= Simple_Type
      | '(' Type_Expr ')'
\end{lstlisting}

Types in \Aml comprise three interconnected elements of the language:
\begin{itemize}
  \item Blueprints of values, describing structure of each value that is a member of the type, its properties, list of messages that can be sent to the object. 
  \item Designators of those blueprints, which give semantic meaning to the blueprints. Two types may share the same structure, but if they are given different names, the semantic difference is preserved. 
  \item Types are values themselves, making runtime reflection an innate part of the language. 
\end{itemize}





\section{Paths}
\label{sec:type-paths}

\grammar\begin{lstlisting}
Path 
    ::= Stable_Id
      | [id '.'] 'self'
      | 'outer' Class_Qualifier
Long_Id 
    ::= [Path '.'] id
      | [id '.'] 'super' [Class_Qualifier] '.' id
      | 'outer' Class_Qualifier '.' id
      | 'global' '.' id
Stable_Id
    ::= Long_Id
Class_Qualifier 
    ::= '[' Long_Id ']'
\end{lstlisting}

Paths are not types themselves, but they can be a part of named types and in that function form a role in \Aml's type system. 

A path is one of the following:

\begin{itemize}
  \item The empty path $\epsilon$ (which can't be written explicitly in user programs). 

  \item \lstinline@$C$.self@, where $C$ references a class or a trait. The path \code{self} is taken as a shorthand for \lstinline@$C$.self@, where $C$ is the name of the class directly enclosing the reference.\footnote{This is used to refer to a single object. }
  
  \item \lstinline!Function.self!, where \code{Function} is defined by Aml's \code{Language} module (not imported to be anything else), is a reference to the directly enclosing function object and is available only within functions (or methods, anonymous functions, and even blocks).

  \item \lstinline@$p$.$x$@, where $p$ is a path and $x$ is a member of $p$.

  \item \lstinline@$C$.super.$x$@ or \lstinline@$C$.super[$M$].$x$@, where $C$ references a class or a trait and $x$ references a member of the superclass or designated parent class $M$ of $C$. The prefix \code{super} is taken as a shorthand for \lstinline@$C$.super@, where $C$ is the name of the class directly enclosing the reference, and \lstinline@super[$M$]@ as a shorthand for \lstinline@$C$.super[$M$]@, where $C$ is yet again the name of the class directly enclosing the reference. 
\end{itemize}

Paths introduce also {\em path dependent types}, if the referenced member is a type. 





\subsection{Type Variables}
\label{sec:type-variables}

\grammar\begin{lstlisting}
Stable_Id 
    ::= ...
      | Type_Var
Type_Var 
    ::= ''' plain_id
      | '''' plain_id
\end{lstlisting}

A type ``\,\lstinline!'$x$!\,'' stands for a type variable named $x$. A type ``\,\lstinline!''$x$!\,'', moreover, comes with a type context, ~\lstinline!Equality '$x$ => '$x$!, which is added to the type where it appears (or is exactly that if the type comprise just the type variable). 

Type variables, unlike type parameters, may also be unified with a specific type by the automatic type inference, and may be made explicitly polymorphic. 





\subsection{Self Path}
\label{sec:self-path}

The path ~\lstinline@$C$.self@~ and its derivatives are not really special within \Aml, because it is possible to bind the object (that ~\lstinline@$C$.self@~ would otherwise refer to) to a different name, say $t$. In such a case, ~\lstinline@$t$@~ can then be used throughout \Aml's type system as ~\lstinline@$C$.self@~ would have been used. The only difference is then that ~\lstinline@$C$.$t$@~ is not allowed to be used to resolve which \code{self} is meant to be used -- but that is the whole point of renaming that particular \code{self} to $t$, to not have to explicitly write the whole (possibly long) path. 






\section{Value Types}

Every value in Aml has a type which is of one of the following forms. Remember that the grammar elements from the following sections are used in contexts where a type is expected -- not any general expression. 





\subsection{Singleton Type}
\label{sec:singleton-types}

\grammar\begin{lstlisting}
Simple_Type 
    ::= Singleton_Type
Singleton_Type
    ::= Path '.' 'type'
\end{lstlisting}

A singleton type is of the form ~\lstinline@$p$.type@, where $p$ is a path pointing to a value. The type denotes the set of values consisting of solely the value denoted by $p$.

A {\em stable type} is either a singleton type or a type which is declared to be a subtype of a trait \code{Singleton_Type}. 





\subsection{Cloned Type}
\label{sec:cloned-types}

\grammar\begin{lstlisting}
Simple_Type 
    ::= ...
      | Cloned_Type
Cloned_Type
    ::= Path '.' 'type' '.' 'cloned'
\end{lstlisting}

A cloned type is of the form ~\lstinline!$p$.type.cloned!, where $p$ is a path pointing to a value. The type denotes the set of values consisting of the value denoted by $p$ and every value that is cloned from the value denoted by $p$. 

A {\em stable type} is either a cloned type or a type which is declared to be a subtype of a trait \code{Cloned_Type}. Singleton in this view appears to be a special case (more concrete to be precise) of a cloned type, excluding the cloned values. 





\subsection{Literal-Based Singleton Type}
\label{sec:literal-based-singleton-type}

\grammar\begin{lstlisting}
Simple_Type 
    ::= ...
      | Literal_Type
Literal_Type
    ::= Literal ['.' 'type']
\end{lstlisting}

A singleton type based on a literal is of the form \lstinline@$l$.type@, where $l$ is a literal. The type denotes the set of values consisting of every literal value that is equal to $l$. 

A {\em stable type} is either a literal-based singleton type or a type which is declared to be a subtype of a trait \code{Literal_Singleton_Type}. 

In contexts where a type is expected\footnote{Most notably type arguments or type annotations of variables or function result types.}, the ``\code{.type}'' part of the type can be omitted. 





\subsection{Type Projection}
\label{sec:type-projection}

\grammar\begin{lstlisting}
Simple_Type 
    ::= ...
      | Projected_Type
Projected_Type
    ::= Simple_Type ('#' | '.#') id
\end{lstlisting}

A type projection \lstinline@$T$#$x$@ references type member named $x$ of type $T$. This is useful i.e. with nested classes that belong to the class instances, not the class object. 

% example based on: http://stackoverflow.com/a/9444487/473180
\example A sample code that shows off what type projections are good for:
\begin{lstlisting}
class A = object
  class B = object end
  method f (b: B): Unit   = Console.print_line "Got my B."
  method g (b: A#B): Unit = Console.print_line "Got a B."
end

let 
  val a1 = A()
  val a2 = A() 
in
  begin
    a2.f a1.B()   -- type mismatch, found a1.B, required a2.B
    a2.g a1.B()   -- prints "Got a B." to stdout
    a2.f a2.B()   -- prints "Got my B." to stdout
  end
\end{lstlisting}
This is due to the fact that the \code{class B} is defined as a class instance member of \code{class A}, not as a class object member (either via object definition (\sref{sec:object-definitions}) or some form of metaclass access (\sref{sec:metaclasses})). Therefore, \code{a1.B} refers to type member \code{B} of the instance \code{a1}, but not of \code{a2}. Moreover, \code{A.B} is not defined here. 

% TBD: add example with graphs from http://www.scala-lang.org/old/node/115, as Aml does the same thing






\subsection{Type Designators}
\label{sec:type-designators}

\grammar\begin{lstlisting}
Simple_Type 
    ::= ...
      | Stable_Id
      | Selected_Type
      | Self_Type_Expr
Selected_Type
    ::= Parameterized_Type '.' Long_Id
Self_Type_Expr
    ::= 'Self'
\end{lstlisting}

A type designator refers to a named value type. It can be simple or qualified. All such type designators are shorthands for type projections. 

Specifically, the unqualified type name $t$ where $t$ is bound in some class, object or structure $C$ is taken as a shorthand for ~\lstinline@$C$.self.type#$t$@.\footnote{Note that in objects and structures, the designator~\lstinline@$C$.self@ refers to that object or structure, whereas in classes, it refers to instances of that class.} If $t$ is not bound in a class, object or structure, then $t$ is taken as a shorthand for ~\lstinline@$\epsilon$.type#$t$@. 

A qualified type designator has the form ~\lstinline@$p$.$t$@, where $p$ is a path (\sref{sec:type-paths}) and $t$ is a type name. Such a type designator is equivalent to the type projection ~\lstinline@$p$.type#$t$@. 

The type designator ~\lstinline!self!~ refers to the singleton type ~\lstinline!self.type!, and ~\lstinline!$C$.self!~ refers to the singleton type ~\lstinline!$C$.self.type!. Aml also defines a designator named \code{Self}, which refers to the enclosing class type. 

% TBD: describe the Self_Type_Expr (similar to Swift)

\example Some type designators and their expansions are listed below, the type designator being on the left and the expansion on the right of ``\code{=}''. 
\begin{lstlisting}
t = $\epsilon$.type#t         -- "global space", not real code
-- predefined import of Aml/Language
Number = Aml/Language.type#Number 

val An_Object = object
  type t = $\ldots$ end
  t = An_Object.type#t        -- bound by standalone object
end

class A_Class = object
  type t = $\ldots$ end
  method a_method = begin
    t = A_Class.self.type#t   -- bound by class
    t = self.type#t           -- bound by class
  end
  class << self
    type u = $\ldots$ end
    u = A_Class.type#u        -- bound by class object
    t = A_Class.self.type#t   -- bound by class
  end
  
  t = A_Class.self.type#t     -- bound by class
  A_Class.t = A_Class.self.type#t  -- -||-
  A_Class.u = A_Class.type#u  -- bound by class object
  
  u = A_Class.type#u          -- not bound by class, thus bound by class object;
                              -- if class A_Class defined u itself, it would shadow 
                              -- the definition in the class object
end
\end{lstlisting}
% TBD fix the above to fit updated grammar, also finally resolve the class object vs class instances




\subsection{Parameterized Types}
\label{sec:parameterized-types}

\grammar\begin{lstlisting}[deletekeywords={no}]
Simple_Type
    ::= ...
      | Parameterized_Type
Parameterized_Type
    ::= Simple_Type [? no whitespace ? Type_Args]
      | Simple_Type '.' Type_Args
      | Postfix_Parameterized_Type
Postfix_Parameterized_Type 
    ::= Atomic_Type_Arg Stable_Id
Type_Args 
    ::= '[' [Type_Arg {',' Type_Arg}] ']'
Type_Arg 
    ::= Type_Arg_Value
      | Measure_Arg_Value
      | Static_Arg_Value
Atomic_Type_Arg
    ::= Type_Arg_Value
      | '(' Measure_Arg_Value ')'
      | '(' Static_Arg_Value ')'
      | '(' [Type_Arg {',' Type_Arg}] ')'
Type_Arg_Value
    ::= ['~' id ':'] Type
      | '_'
Measure_Arg_Value 
    ::= ['~' id ':'] '<' measure_literal '>'
Static_Arg_Value
    ::= Constant_Expr
      | 'constant' Expr
\end{lstlisting}

A parameterized type $T[T_1 \commadots T_n]$ consists of a type designator $T$ and type parameters $T_1 \commadots T_n$, where $n \geq 1$. $T$ must refer to a type constructor which takes exactly $n$ type parameters $a_1 \commadots a_n$. 

Say the type parameters have lower bounds $L_1 \commadots L_n$ and upper bounds $U_1 \commadots U_n$. The parameterized type is well-formed if each actual type parameter {\em conforms to its bounds}, so that $\sigma L_i <: T_i <: \sigma U_i$, where $\sigma$ is the substitution $[a_1 \mapsto T_1 \commadots a_n \mapsto T_n]$\footnote{The substitution works by replacing occurrences of $a_i$ in the argument by $T_i$, so that, e.g. ~\lstinline!$A$ <: Comparable[$A$]!~ is substituted into ~\lstinline!$C$ <: Comparable[$C$]!.}. Also, $U_i$ must never be a subtype of $L_i$, since no other type ever would be able to fulfill the bounds ($U_i$ and $L_i$ may be the exact same type though, but in that case the type parameter would be invariant and the whole point of having a parameterized type would be useless). 

Each type argument may be given a name $n$, using the form ``\lstinline!~$n$: $T$!''. This attaches the annotation ~\lstinline!@[labelled :$n$]!~ to the type argument. 

A type may be parameterized by at most two type parameter clauses, although the second one is managed by the Aml system and can't be passed type arguments explicitly. Such a second type parameter clause is called {\em shadow type parameter clause} and can't be written in user programs explicitly, but may examined in runtime using reflection. 

\example
\label{example:parameterized-types}
Given the generic type definitions: 

\begin{lstlisting}
class Tree_Map['a <: Comparable['a], 'b] = object $\ldots$ end
class 'a list = object $\ldots$ end
class I = object inherit Comparable[I]; $\ldots$ end

class F['m[_], 'x] = object $\ldots$ end
class S['k <: String] = object $\ldots$ end
class G['m['z <: 'i], 'i] = object $\ldots$ end

trait Function[-'t, +'r] = object $\ldots$ end
\end{lstlisting}

the following parameterized types are well-formed: 

\begin{lstlisting}
Tree_Map[I, String]
List[I]
List[List[Boolean]]

F[List, Number]
G[S, String]

Function[named: List[String], String]
\end{lstlisting}

\example
\label{example:parameterized-types-mal}

Given the type definitions of the previous example, the following types are malformed: 

\begin{lstlisting}
Tree_Map[I]               -- wrong number of parameters
Tree_Map[List[I], Number] -- type parameter List not within bound

F[Number, Boolean]        -- Number is not a type constructor
F[Tree_Map, Number]       {- Tree_Map takes two parameters, 
                             F expects a type constructor taking one -}

G[S, Number]              {- type S constrains its parameter to
                             conform to String, 
                             G expects type constructor with a parameter
                             that conforms to Number -}
\end{lstlisting}

\example Alternative syntax enabled by postfix type declaration:

\begin{lstlisting}
Integer list         -- equivalent to List[Integer]
'i list              -- equivalent to List['i]
String list          -- equivalent to List[String]
Boolean list list    -- equivalent to List[List[Boolean]]
\end{lstlisting}





\subsection{Polymorphic Variant Types}
\label{sec:polymorphic-variant-types}

\grammar\begin{lstlisting}[deletekeywords={not,with,or}]
Simple_Type 
    ::= ...
      | Polymorphic_Variant_Type
Polymorphic_Variant_Type 
    ::= '[' Tag_Spec {semi Tag_Spec} ']'
      | '[>' [Tag_Spec {semi Tag_Spec}] ']'
      | '[<' Tag_Spec {semi Tag_Spec} [semi '>' {Tag_Name}+] ']'
Tag_Spec 
    ::= Tag_Name ['of' Type]
      | Type
Tag_Name 
    ::= '`' ? id that does not start with ` ?
\end{lstlisting}

Polymorphic variant types describe the values a polymorphic variant may take. 

The first case (\lstinline![ ts$_1$; $\ldots$; ts$_n$ ]!) is an {\em exact polymorphic variant type}: all possible tags are known, with their associated types, and they can all be present in values; its structure is fully known. 

The second case (\lstinline![> ts$_1$; $\ldots$; ts$_n$ ]!) is an {\em open polymorphic variant type}, describing a polymorphic variant value: it givs the list of all tags the value could take, with their associate types, and this type is still compatible with a polymorphic variant type containing more tags. A special case is the unknown type (\lstinline![> ]!), which does not define any tag, and therefore is compatible with any polymorphic variant type. 

The third case (\lstinline![< ts$_1$; $\ldots$; ts$_m$; > `Tag$_n\ \ldots$ `Tag$_o$ ]!) is a {\em closed polymorphic variant type}. It gives information on all the possible tags and their associated types, along with which tags are known to potentially appear in values. The exact variant type from the first case is equivalent to a closed variant type where all possible tags are also potentially present in values. 

In all cases, tags may be either specified directly in the ~\lstinline!`Tag!~ and ~\lstinline!`Tag of $T$!~ forms, or indirectly through a type, which must expand to an exact polymorphic variant type, whose tag specifications are inserted in place. 

Intersection-like types may be given in closed polymorphic variant types, likely generated by automatic type inference. Such type may be conjunctive, include multiple incompatible class types, and therefore inherently unsatisfiable. Such a constraint signals an error condition. 





\subsection{Tuple Types}
\label{sec:tuple-types}

\grammar\begin{lstlisting}
Simple_Type 
    ::= ...
      | '(' Types ')'
Tuple_of_Types
    ::= Type_Expr {',' Type_Expr}
Infix_Type 
    ::= ...
      | Type_Expr {'*' Type_Expr}
\end{lstlisting}

A tuple type ($T_1 \commadots T_n$) is an alias for the class \lstinline@Tuple[$T_1 \commadots T_n$]@, where $n \geq 1$. 

A tuple type $T_1 * \ldots * T_n$ is an infix type (\sref{sec:infix-types}) representing the exact same tuple type as ($T_1 \commadots T_n$).

Tuple classes are available as patterns for pattern matching. The properties can be accessed as methods ~\lstinline!1$ \commadots n$!. 

Tuple classes are generated lazily by the runtime as needed, so that the language does not constrain users to tuples of only limited sizes, but allows any size. 

If any of the tuple's type arguments $T_i$ is annotated to be named $n$ (see \sref{sec:parameterized-types}, then annotation ~\lstinline!@[labelled :$n$]!~ is added to the type argument. 

Tuple type with single type parameter is an alias for the type parameter itself. This is true for the form ~\lstinline!($T$)!~ as well as ~\lstinline!Tuple[$T$]!.






\subsection{Annotated Types}

\grammar\begin{lstlisting}
Annot_Type 
    ::= {Annotation} Simple_Type
\end{lstlisting}

An annotated type $a_1 \ldots a_n T$ attaches annotations (\sref{sec:annotations}) $a_1 \commadots a_n$ to the type $T$. 





\subsection{Infix Types}
\label{sec:infix-types}

\grammar\begin{lstlisting}
Infix_Type 
    ::= Type_Expr {[nl] (Infix_Op - 'and also', 'or else') [nl] Type_Expr}
\end{lstlisting}

An infix type $T_1\ \op\ T_2$ consists of an infix operator $\op$, which gets applied to two type operands $T_1$ and $T_2$. The type is equivalent to the type application ~\lstinline!$\op$[$T_1$, $T_2$]!. The infix operator $\op$ may be an arbitrary identifier, and is expected to represent a type constructor. 

Infix type may also result from an infix expression (\sref{sec:prefix-infix-ops}), if such operator name is not found on the result type of the expression that it is applied to. In any case, precedence and associativity rules of operators apply here as well. 





\subsection{Unions}
\label{sec:unions}

\grammar\begin{lstlisting}
Infix_Type
    ::= ...
      | Type {'or' Type}
\end{lstlisting}

Union types represent multiple types, possibly unrelated. Union types are abstract by nature and can not be instantiated, only the types that they contain may, if these are instantiable. For type safety, bindings of union types should be matched for the actual type prior to usage. 

Unions are indeed virtually ``tagged'' with the actual type that they represent at the runtime moment, although when it comes to overloading resolution, the union type is used, as it is the expected type. 

The first syntax shows a named union type, while the second shows an anonymous union type (which may still be given a name later). If any of the types that are a part of a union type is a union type itself, the two types are merged. The syntax used for the anonymous version is correlating with infix type syntax, but this syntax gives it the meaning of a union type, which is preferred to infix type syntax. In fact, it might be implemented with an infix type that generates union types:

\begin{lstlisting}
type or [A, B] = Union[A, B] 
end
\end{lstlisting}

Union types also employ the following set of rules, given some types \code{X}, \code{Y} and \code{Z}:
\begin{itemize}
  \item Commutativity: \code{X or Y} is equivalent to \code{Y or X}. 
  \item Associativity: \code{X or (Y or Z)} is equivalent to \code{(X or Y) or Z}, which is equivalent to \code{X or Y or Z}. 
  \item Simplification: if \code{X} conforms to \code{Y}, then \code{X or Y} is equivalent to \code{Y}. 
  \item Conformance: \code{X} conforms to \code{X or Y}. 
  \item Supertypes: if both \code{X} and \code{Y} conform to \code{Z}, then \code{X or Y} also conforms to \code{Z}. 
  
  \item \code{X or Nothing} is equivalent to \code{X} for any \code{X}. 
  \item \code{X or Any} is equivalent to \code{Any} for any \code{X}. 
  
  \item If \code{X[T]} is covariant in the type parameter \code{T}, then \code{X[U] or X[V]} conforms to \code{X[U or V]} for any types \code{U} and \code{V} that satisfy the type constraints of T. 
  \item If \code{X[T]} is contravariant in the type parameter \code{T}, then \code{X[U] or X[V]} conforms to \code{X[U with V]} for any types \code{U} and \code{V} that satisfy the type constraints of T. 
\end{itemize}





\subsection{Intersection Types}
\label{sec:intersection-types}

\grammar\begin{lstlisting}
Infix_Type 
    ::= ...
      | Type_Expr ['with' Type_Expr] {'and' Type_Expr}
\end{lstlisting}

An intersection type is a type that conforms to all types that it consists of. Any value that is an instance of all the types is also an instance of the intersection type. The second connected type may be optionally separated using ``\code{with}'' instead of ``\code{and}''.

Intersection types also employ the following set of rules, given some types \code{X}, \code{Y} and \code{Z}:
\begin{itemize}
  \item Commutativity: \code{X and Y} is equivalent to \code{Y and X}. 
  \item Associativity: \code{X and (Y and Z)} is equivalent to \code{(X and Y) and Z}, which is equivalent to \code{X and Y and Z}. 
  \item Simplification: if \code{X} conforms to \code{Y}, then \code{X and Y} is equivalent to \code{X}. 
  \item Conformance: \code{X and Y} conforms to \code{X}. 
  \item Subtypes: if \code{Z} conforms to both type \code{X} and type \code{Y}, then \code{Z} also conforms to \code{X and Y}. 
  \item Distributivity over union: \code{X and (Y or Z)} is equivalent to \code{(X and Y) or (X and Z)}. 
  
  \item \code{X and Nothing} is equivalent to \code{Nothing} for any \code{X}.
  \item \code{X and Any} is equivalent to \code{X} for any \code{X}. 
  
  \item If \code{X[T]} is covariant in the type parameter \code{T}, then \code{X[U and V]} conforms to \code{X[U] and X[V]} for any types \code{U} and \code{V} that satisfy the type constraints of T. 
  \item If \code{X[T]} is contravariant in the type parameter \code{T}, then \code{X[U or V]} conforms to \code{X[U] and X[V]} for any types \code{U} and \code{V} that satisfy the type constraints of T. 
\end{itemize}





\subsection{Function Types}
\label{sec:function-types}

\grammar\begin{lstlisting}
Type_Expr
    ::= ...
      | Function_Type
Function_Type 
    ::= First_Function_Arg_Type {'->' Function_Arg_Type}
        ['->' Signalling_Types] '->' Atomic_Type_Expr
First_Function_Arg_Type
    ::= Function_Arg_Type
      | '(' 'val' Type_Expr ')'
Function_Arg_Type
    ::= [('~' | '~?') id ':' | '*' | '**' | '&'] Atomic_Type_Expr
Signalling_Types
    ::= Signalling_Kind {'and' Signalling_Kind}  -- each kind at most once
Signalling_Kind
    ::= 'signals' (Simple_Type | '(' Type_Expr {',' Type_Expr} ')')
      | 'throws'  (Simple_Type | '(' Type_Expr {',' Type_Expr} ')')
      | 'raises'  (Simple_Type | '(' Type_Expr {',' Type_Expr} ')')
      | 'resignals'
      | 'rethrows'
      | 'reraises'
\end{lstlisting}

The type \lstinline@($T_1 \commadots T_n$) -> $R$@ represents the set of function values that take arguments of types $T_1 \commadots T_n$ and yield results of type $R$. In the case of exactly one argument, type \lstinline@$T$ -> $R$@ is a shorthand for \lstinline@($T$) -> $R$@. 

Function argument types may be annotated with some extra properties. In that case, these map to annotations of their types, defined as follows:
\begin{itemize}
  \item ``\,\code{*}\,'' maps to \code{@[variadic]}. 
  \item ``\,\code{**}\,'' maps to \code{@[capture_variadic]}. 
  \item ``\,\code{&}\,'' maps to \code{@[captured_block]}. 
  \item ``\,\lstinline!~$\id$!\,'' maps to \code{@[named :$\id\,$]}. 
  \item ``\,\lstinline!~?$\id$!\,'' maps to \lstinline[deletekeywords={optional}]!@[named :$\id\,$] @[optional]!. 
\end{itemize}

Function types associate to the right, e.g. \lstinline@($S$) -> ($T$) -> $R$@ is the same as \lstinline@($S$) -> (($T$) -> $R$)@. 

Function types are shorthands for class types that conform to the \lstinline@Function@ protocol -- i.e. having an \code{apply} function or simply {\em being} a function. The tuple-destructuring function type \lstinline@($T_1 \commadots T_n$) -> $R$@ is a shorthand for the protocol \lstinline@Function[$T_1 * \ldots * T_n,\,R$]@. Such protocol is defined in the Aml library:

\begin{lstlisting}
protocol Function[-$T$, +$R$]
  message apply ($x_1$: $T$): $R$
  $\ldots$
end protocol
\end{lstlisting}

Function types are covariant in their result type and contravariant in their argument type (\sref{sec:variance-of-type-parameters}).

A function that returns ``nothing'' may be declared as returning the type \code{Unit}, which is similar to \lstinline[language=C]!void! in C-related languages. Such a type is then written as ~\lstinline!($S$) -> Unit!. 

\paragraph{Note}
Although the function type alone allows to attach the extra annotations to types of arguments in a \code{1:1} manner (and therefore types of parameters), due to how conformance is defined for function types, it is not always desirable to use them. The only argument extra that might be of any use is the captured block argument, so that a requirement of a passed block is marked (not caring about the actual style of the block passing). 

\example The following definition of functions \code{g} and \code{h} conform to a definition of a function \code{f}, and there are many more such functions that conform to \code{f}. And vice versa, \code{f} conforms to both \code{g} and \code{h}, although the latter two are more specific than the first one (\sref{sec:overloading-resolution}). 
\begin{lstlisting}
def f (*x: Integer) end
def g (x: Integer, y: Integer) end
def h (x: Integer, y: Integer, z: Integer) end
\end{lstlisting}





\subsection{Type Class Constraints}

\grammar\begin{lstlisting}
Type_Context 
    ::= Simple_Type '=>'
      | '(' Types ')' '=>'
Given_Dcl
    ::= 'class' Type
\end{lstlisting}

A function type can additionally express type class constraints, either with the prefix syntax using \code{Type_Context}, or the postfix syntax using \code{Given_Clauses}. Each type occurring in either of those is considered to be adding a type class constraint to the function type (\sref{sec:type-class-constrained-types}). 

\example A function type that requires that an instance of a type class \code{Show['a]} is available for the type parameter \code{'a}.
\begin{lstlisting}
Show['a] => 'a -> 'b for all { type 'a; type 'b }
\end{lstlisting}

\example A function type that is equivalent to the previous type, but uses only the postfix syntaxes. 
\begin{lstlisting}
'a -> 'b given Show['a] and for all { type 'a; type 'b }
\end{lstlisting}

\paragraph{Note}
A good style is to not combine the two syntaxes in one function type, however, if so used, the constraints are concatenated. 





\subsection{Functional Dependencies}

\grammar\begin{lstlisting}
Given_Dcl 
    ::= ...
      | Simple_Type '~>' Simple_Type
\end{lstlisting}

A functional dependency expresses dependencies between type parameters of a function type. A functional dependency in form of ~\lstinline!'a ~> 'b!~ expresses the fact that type variable \code{'a} determines the type variable \code{'b}. Note that the involved type variables are still unifiable at that point, unless made explicitly polymorphic. 





\subsection{Type Dependencies, Constraints \& Equations}

\grammar\begin{lstlisting}
Given_Dcl 
    ::= ...
      | Stable_Id Type_Equation
      | Stable_Id '>:' Type_Expr ['<:' Type_Expr]
      | Stable_Id '<:' Type_Expr
      | Type_Vars ':' '(' Member_Signature {semi Member_Signature} ')'
      | Stable_Id ':' '(' Constructor_Signature ')'
Type_Vars 
    ::= Stable_Id
      | '(' Stable_Id {'or' Stable_Id} ')'
Member_Signature
    ::= ['object' | 'class'] 'member' fun_id ':' Type_Expr
      | ['object' | 'class'] 'message' fun_id ':' Type_Expr
      | ['object' | 'class'] 'attribute' fun_id ':' Type_Expr
      | ['object' | 'class'] 'operator' op_id ':' Type_Expr
      | ['object' | 'class'] 'property' id ':' Type_Expr 
        ['with' Property_Signature_Extra]
Constructor_Signature
    ::= 'new' ':' Type_Expr  -- just type of parameters, no result type
Property_Signature_Extra
    ::= 'get' ['and' 'set']
      | 'set' ['and' 'get']
\end{lstlisting}

A type dependency or equation expresses additional relations between different type components (usually type variables used as type parameters) that make up a type that uses the \code{given} declarations. It can equate two types (e.g. ~\lstinline!given {'a = 'b}!), or declare that two or three types have a conformance relation (e.g. ~ \lstinline!given {'a >: 'b <: 'c}!).





\subsection{Existentially Quantified Types}
\label{sec:existential-types}

\grammar\begin{lstlisting}
Existential_Clauses
    ::= 'for' 'some' '{' Quantification_Dcl {semi Quantification_Dcl} '}'
Quantification_Dcl
    ::= Type_Declaration
      | 'val' id ':' Type_Expr
Type_Arg
    ::= ...
      | Wildcard_Type_Arg
Wildcard_Type_Arg
    ::= '?' ['>:' Type_Expr] ['<:' Type_Expr] 
\end{lstlisting}

An existential type has the form ~\lstinline@$T$ for some { $Q$ }@, where $Q$ is a sequence of type declarations (\sref{sec:type-decls-aliases}). Let ~\lstinline@$t_1$[$\tps_1$] >: $L_1$ <: $U_1\ \commadots\ t_n$[$\tps_n$] >: $L_n$ <: $U_n$@~ be the types declared in $Q$ (any of the type parameter sections ~\lstinline![$\tps_i$]!~ might be missing). The scope of each type $t_i$ includes the type $T$ and the existential clause $Q$. The type variables $t_i$ (occurring in the sequence $Q$) are said to be {\em bound} in the type ~\lstinline!$T$ for some { $Q$ }!. Type variables that occur in a type $T$, but which are not bound in $T$, are said to be {\em free} in $T$. 

A type variable bound in $T$ is also explicitly polymorphic. 

A {\em type instance} of ~\lstinline@$T$ for some { $Q$ }@~ is a type $\sigma T$, where $\sigma$ is a substitution over $t_1 \commadots t_n$, such that for each $i$, $\sigma L_i \conforms \sigma t_i \conforms \sigma U_i$. The set of values denoted by the existential type \lstinline@$T$ for some { $Q$ }@ is the union of the set of values of all its type instances. In other words, a type instance of an existential type is a type application (\sref{sec:type-applications}) of the type ~\lstinline@$T$ for some { $Q$ }@, where the applied type arguments conform to the bounds, or are free in ~\lstinline@$T$ for some { $Q$ }@. 

A {\em skolemization} of ~\lstinline@$T$ for some { $Q$ }@~ is a type instance $\sigma T$, where $\sigma$ is the substitution $[t_1 \mapsto t'_1 \commadots t_n \mapsto t'_n]$ and each $t'_i$ is a fresh abstract virtual type with lower bound $\sigma L_i$ and upper bound $\sigma U_i$\footnote{This virtual type $t'_i$ denotes the set of all types, for which $\sigma L_i \conforms \sigma t'_i \conforms \sigma U_i$.}. Such type instance is inaccessible to user programs, but is essential to type equality and conformance checks, as it describes the set of values denoted by the existential type without an actual existential type, but with a universal type. 



\paragraph{Simplification rules}
Existential types obey the following equivalences:
\begin{enumerate}
\item
Multiple \code{for some} clauses in an existential type can be merged. E.g., ~\lstinline@$T$ for some { $Q$ } for some { $Q'$ }@~ is equivalent to ~\lstinline@$T$ for some { $Q$; $Q'$ }@. 

\item
Unused quantifications can be dropped. E.g., ~\lstinline@$T$ for some { $Q$; $Q'$ }@, where none of the types defined in $Q'$ are referred to by $T$ or $Q$, is equivalent to ~\lstinline@$T$ for some { $Q$ }@. 

\item
An empty quantification can be dropped. E.g., ~\lstinline@$T$ for some { }@~ is equivalent to $T$. 

\item
An existential type ~\lstinline@$T$ for some { $Q$ }@, where $Q$ contains a clause ~\lstinline!type $t$[$\tps$] >: $L$ <: $U$!~ is equivalent to the type ~\lstinline@$T'$ for some { $Q$ }@, where $T'$ results from $T$ by replacing every covariant occurrence (\sref{sec:variance-of-type-parameters}) of $t$ in $T$ by $U$ and by replacing every contravariant occurrence of $t$ in $T$ by $L$. 
\end{enumerate}



\paragraph{Existential quantification over values}
As a syntactic convenience, the bindings clause in an existential type may also contain value declarations ~\lstinline!val $x$: $T$!. An existential type ~\lstinline@$T$ for some { $Q$; val $x$: $S$; $Q'$ }@~ is treated as a shorthand for the type ~\lstinline@$T'$ for some { $Q$; type $t$ <: $S$ with Singleton_Type; $Q'$ }@, where $t$ is a fresh type name and $T'$ results from $T$ by replacing every occurrence of ~\lstinline!$x$.type!~ with $t$. 



\paragraph{Placeholder syntax for existential types}
\label{par:placeholder-existential-types}
Aml supports a placeholder syntax for existential types. A {\em wildcard type} is of the form ~\lstinline!? >: $L$ <: $U$!~ and may only appear as a type argument. Both bound clauses may be omitted. If a lower bound clause ~\lstinline!? >: $L$!~ is omitted, ~\lstinline!? >: Nothing!~ is assumed. If an upper bound clause ~\lstinline!? <: $U$!~ is omitted, ~\lstinline!? >: Object!~ is assumed. A wildcard type is a shorthand for an existentially quantified type variable, where the existential quantification is implicit.\footnote{Although the syntax for existential types is heavily influenced by Scala, the particular syntax for the placeholder itself was chosen from Java, as the underscore, which is used in Scala, is already used by wildcard type argument for partial type applications.}

A wildcard type must appear as a type argument of a parameterized type. Let ~\lstinline!$T$ = $p$.$c$[$\targs$, $T$, $\targs'$]!~ be a parameterized type, where $\targs$, $\targs'$ may be empty and $T$ is a wildcard type ~\lstinline!_ >: $L$ <: $U$!. Then $T$ is equivalent to the existential type
\begin{lstlisting}
$p$.$c$[$\targs$, $t$, $\targs'$] for some { type $t$ >: $L$ <: $U$ }
\end{lstlisting}
where $t$ is a fresh type variable. 

\example Assume the class definitions
\begin{lstlisting}
class Ref['t] = object ... end
abstract class Outer = object 
  type T
end
\end{lstlisting}

Here are some examples of existential types:
\begin{lstlisting}
Ref[T] for some { type T <: Number }
Ref[x.T] for some { val x: Outer }
Ref[x_type#T] for some { type x_type <: Outer with Singleton_Type }
\end{lstlisting}

The last two types in this list are equivalent. An alternative formulation of the first type above using wildcard syntax is:
\begin{lstlisting}
Ref[? <: Number]
\end{lstlisting}

which is equivalent to Java's
\begin{lstlisting}[language=Java]
Ref<? super Number>
\end{lstlisting}

\lstinline!Ref[? <: Number]!~ then represents any type constructed by the type\code{Ref} parameterized with a type that is \code{Number} or any type that conforms to \code{Number}. 

\lstinline!Ref[? >: Number]!~ would then represents any type constructed by the type \code{Ref} parameterized with a type that is \code{Number} or any type that \code{Number} conforms to. 

\example The type ~\lstinline!List[List[_]]!~ is equivalent to the existential type
\begin{lstlisting}
List[List[T] for some { type T }]  .
\end{lstlisting}

\example Assume a covariant type
\begin{lstlisting}
type List[+T] = ... end
\end{lstlisting}

The type 
\begin{lstlisting}
List[T] for some { type T <: Number }
\end{lstlisting}

is equivalent (by simplification rule 4 above\footnote{As ~\lstinline!T!~ appears in covariant position in \code{List}, its upper bound can replace the type variable in \code{List}.}) to
\begin{lstlisting}
List[Number] for some { type T <: Number }
\end{lstlisting}

which is in turn equivalent (by simplification rules 2 and 3 above\footnote{The type variable ~\lstinline!T!~ is unused, and after dropping it, the quantification is empty.}) to
\begin{lstlisting}
List[Number]  .
\end{lstlisting}

Since this \code{List} type is covariant in its type parameter, then e.g. ~\lstinline!List[Integer]!~ is still a subtype of ~\lstinline!List[Number]!. 





\subsection{Explicitly Universally Quantified Types}
\label{sec:universal-types}

\grammar\begin{lstlisting}
Universal_Clauses 
    ::= {'for' 'all' '{' Quantification_Dcl {semi Quantification_Dcl} '}'}
\end{lstlisting}

A type variable bound in $T$ is also explicitly polymorphic. 





\subsection{Nullable Types}
\label{sec:nullable-types}

\grammar\begin{lstlisting}[deletekeywords={no}]
Simple_Type
    ::= ...
      | Simple_Type ? no whitespace ? Nullable_Mod
Nullable_Mod 
    ::= '?'
\end{lstlisting}

A nullable type has the form \lstinline!$T$?!, which is an abbreviation for \lstinline!Option[$T$]!.

For intersection types (\sref{sec:intersection-types}), the nullability modifier has to be applied to the first connected type, i.e. \lstinline!$T_1$? with $T_2$ and $T_3 \ldots T_n$!, which is then equivalent the type \lstinline!Option[$T_1$ with $T_2$ and $T_3 \ldots T_n$]!. 





\subsection{Types Preventing Nil}
\label{sec:types-preventing-nil}

In Aml, a type class exists that makes every type that implements it conform to a compatible non-nullable type: \code{Default[$T$]}. 

\code{Default[$T$]} does that by implementing a default value to runtime-replace \code{nil}. 

Types \code{T} that have got the \code{Default[$T$]} type class implemented have got an implicit conversion from type \code{Option[$T$]} to the type \code{T} enabled, rendering \code{Option[$T$]} compatible with \code{T}.








\subsection{Constrained Types}
\label{sec:constrained-types}

\grammar\begin{lstlisting}
Type_Constraint_Clause 
    ::= 'where' Constraint_Block
Constraint_Block 
    ::= '{' [var_id '->'] Expr '}'
\end{lstlisting}

A constrained type constructs a subset of allowed members of its component type. Such a subset is defined as members for which the constraint function returns boolean \code{yes}. Constraints defined within the component type are implicitly available in such function. 

Constrained types, in face of overloading, force strict argument expression evaluation, so that the constrained type of a parameter can be checked at binding time.\footnote{Therefore, constrained types are not really suitable candidates for parameters that are supposed to be non-strictly evaluated, unless the strict evaluation is intended.}

The constraint function is only applied when a value is tested for membership of the constrained type, i.e. at {\em binding time}, be it argument type check, result type check or any other. This has implications on type soundness -- if the tested value is modified after the binding is done, it may not be a member of the constrained type subset any more, but it is definitely still a member of the component type.\footnote{This is because values in \Aml are not allowed to change their type membership in runtime.}

\paragraph{Note}
Constrained types are an implementation of {\em dependent types} in Aml. Dependent types are basically functions from values to types, where the value part is present in the defined constraint and/or the constraint block. 





\subsection{Types with Explicit Eagerness}
\label{sec:explicit-eagerness-types}

\grammar\begin{lstlisting}[deletekeywords={no}]
Simple_Type
    ::= ...
      | Eagerness_Type_Prefix ? no whitespace ? Simple_Type
Eagerness_Type_Prefix
    ::= Explicitly_Strict_Type_Prefix
      | Explicitly_Lazy_Type_Prefix
Explicitly_Strict_Type_Prefix
    ::= '!'
Explicitly_Lazy_Type_Prefix
    ::= '~'
\end{lstlisting}

An {\em explicitly strict type} \lstinline@!$T$@ is requesting \Aml to reduce the expression bound to type $T$ in a strict way, even when it would resolve to non-strict reduction otherwise.
 
An {\em explicitly lazy type} \lstinline@~$T$@ is requesting \Aml to reduce the expression bound to type $T$ in a non-strict way, even when it would resolve to strict reduction otherwise.





\subsection{Foreign Types}
\label{sec:foreign-types}

\grammar\begin{lstlisting}
Simple_Type 
    ::= ...
      | Foreign_Type
Foreign_Type 
    ::= 'foreign' lang_name string_literal
lang_name 
    ::= id
\end{lstlisting}

A {\em foreign type} is a tool that helps Aml programs integrate with other languages written for the same VM, the Aml VM. It is viewed as extending the type \code{Any}, can be given an alias name and be a part of a compound type with another foreign types or Aml types. 

\paragraph{Parameterized foreign types}
If the foreign type is parameterized, it can be a part of a type application as well, but its type parameters are not declared neither defined on the Aml side. Also, the foreign language defines how the parameterization works -- e.g., Java does type erasure with its type parameters.

\example A foreign type aliases for a few foreign types:
\begin{lstlisting}
type Java_Object = foreign Java "java.lang.Object" end type
type Java_int = foreign Java "int" end type
type CS_Object = foreign `C#` "System.Object" end type
type Rb_Proc_Status = foreign Ruby "Process::Status" end type
\end{lstlisting}






\section{Base Types \& Member Definitions}
\label{sec:base-types}
\label{sec:member-definitions}

Types of class members depend on the way the members are referenced. Central here are these notions:
\begin{enumerate}
  \item The notion of the set of base types of a type $T$.
  \item The notion of a type $T$ in some class $C$ seen from some prefix type $S$.
  \item The notion of the set of member bindings of some type $T$. 
\end{enumerate}

These notions are defined mutually recursively as follows. 

\begin{enumerate}
  \item  The set of {\em base types} of a type is a set of class types, given as follows.
    \begin{itemize}
      \item The base types of a class type $C$ with parents $T_1 \commadots T_n$ are $C$ itself, as well as the base types of the compound type ~\lstinline!$T_1$ with $\ldots$ with $T_n$!. 

      \item The base types of an aliased type are the base types of its alias. 

      \item The base types of an abstract type\footnote{E.g. type members.} are the base types of its upper bound. 

      \item The base types of a parameterized type ~\lstinline!$C$[$T_1 \commadots T_n$]!~ are the base types of type $C$, where every occurence of a type parameter $a_i$ of $C$ has been replaced by the corresponding parameter type $T_i$. 

      \item The base types of a compound type ~\lstinline!$T_1$ with $\ldots$ with $T_n$ with { $R$ }!~ are set of base classes of all $T_i$'s. 

      \item The base types of a type projection ~\lstinline!$S$#$T$!~ are determined as follows: If $T$ is an alias or an abstract type, the previous clauses apply. Otherwise, $T$ must be a (possibly parameterized) class type, which is defined in some class $B$. Then the base types of ~\lstinline!$S$#$T$!~ are the base types of $T$ in $B$ as seen from the prefix type $S$. 

      \item The base types of an existential type ~\lstinline!$T$ for some { $Q$ }!~ are all types ~\lstinline!$S$ for some { $Q$ }!, where $S$ is a base type of $T$. 
    \end{itemize}

  \item The notion of a type {\em $T$ in class $C$ seen from some prefix type $S$} makes sense only if the prefix type $S$ has a type instance of class $C$ as a base type, say ~\lstinline!$S'$#$C$[$T_1 \commadots T_n$]!. Then we define it as follows.
    \begin{itemize}
      \item If ~\lstinline!$S$ = $\epsilon$.type!, then $T$ in $C$ seen from $S$ is $T$ itself. 

      \item Otherwise, if $S$ is an existential type ~\lstinline!$S'$ for some { $Q$ }!, and $T$ in $C$ seen from $S'$ is $T'$, then $T$ in $C$ seen from $S$ is ~\lstinline!$T'$ for some { $Q$ }!. 

      \item Otherwise, if $T$ is the $i^{\superth}$ type parameter of some class $D$, then:
        \begin{itemize}
          \item If $S$ has a base type ~\lstinline!$D$[$U_1 \commadots U_n$]!, for some type parameters $U_1 \commadots U_n$, then $T$ in $C$ seen from $S$ is $U_i$. 
          \item Otherwise, if $C$ is defined in a class $C'$, then $T$ in $C$ seen from $S$ is the same as $T$ in $C'$ seen from $S'$. 
          \item Otherwise, if $C$ is not defined in another class, then $T$ in $C$ seen from $S$ is $T$ itself. 
        \end{itemize}

      \item Otherwise, if $T$ is the singleton type ~\lstinline!$D$.self.type!~ for some class $D$, then:
        \begin{itemize}
          \item If $D$ is a subclass of $C$ and $S$ has a type instance of class $D$ among its base types, then $T$ in $C$ seen from $S$ is $S$. 
          \item Otherwise, if $C$ is defined in a class $C'$, then $T$ in $C$ seen from $S$ is the same as $T$ in $C'$ seen from $S'$. 
          \item Otherwise, if $C$ is not defined in another class, then $T$ in $C$ seen from $S$ is $T$ itself. 
        \end{itemize}

      \item If $T$ is some other type, then the described mapping is performed on all its type components. 

    \end{itemize}

  If $T$ is a possibly parameterized class type, where $T$'s class is defined in some other class $D$, and $S$ is some prefix type, then we use ``$T$ seen from $S$'' as a shorthand for ``$T$ in $D$ seen from $S$''. 

  \item The {\em member bindings} of a type $T$ are:
    \begin{itemize}
      \item All bindings $d$, such that there exists a type instance of some class $C$ among the base types of $T$ and there exists a definition or declaration of $d'$ in $C$, such that $d$ results from $d'$ by replacing every type $T'$ in $d'$ with $T'$ in $C$ seen from $T$.
      \item All bindings of the type's refinement (\sref{sec:compound-types}), if it has one. 
    \end{itemize}

  The definition of a type projection ~\lstinline!$S$#$t$!~ is the member binding $d_t$ of the type $t$ in $S$. In that case, we also say that {\em ~\lstinline!$S$#$t$!~ is defined by $d_t$}. 

\end{enumerate}







\section{Any-Value Type}
\label{sec:any-value-type}

\grammar\begin{lstlisting}[morekeywords={Any},deletekeywords={also}]
Simple_Type ::= 'Any'
-- also:
Simple_Type ::= 'Aml/Language.Any'
\end{lstlisting}

This type does not represent a single concrete value type, but any concrete type. It is used in places where the actual type does not matter, and could be even from other language running along Aml in the VM. 

With respect to overloading resolution (\sref{sec:value-conversions}), this type is always the least specific, as there is no other less specific type available. 

Structural constraints may be appended to this type as with any other type by using a new compound type (\sref{sec:compound-types}), where \code{Any} is used as a class type (never a trait type).

The \code{Any} identifier is not reserved for the language as a keyword, instead, it gets usually automatically imported with the \code{Language} module, and therefore can be shadowed and aliased (e.g. to \code{Any_Object}). 

The \code{Any} virtual type is the actual root of the type system of Aml, although explicit inheritance is not allowed from it. Other languages that integrate with Aml on the same VM may have \code{Any} as their root type as well, disobeying the rule that is set only for Aml. This way, Aml preserves its unified type system. 





\section{Dynamic Type}
\label{sec:dynamic-type}

\grammar\begin{lstlisting}[morekeywords={Dynamic},deletekeywords={also}]
Simple_Type ::= 'Dynamic'
-- also:
Simple_Type ::= 'Aml/Language.Dynamic'
\end{lstlisting}

This type does not represent a single concrete value type\footnote{This type is similar to what ~\lstinline[language={[Sharp]C}]!dynamic!~ is to C\#.}, but any concrete type, very much like \code{Any}. 

In runtime, this type is always dynamically replaced by the type of the actual referenced value -- e.g., if a variable is typed with \code{Dynamic} type (\sref{sec:type-consistency}), assigned a value, and used in a function application, the type of that value is used, not \code{Dynamic}, unless it would be typed with \code{Any} again (\sref{sec:typed-expressions}). Nonetheless, this does not imply that a value of another type can not be assigned to that same variable -- such variable is still bound to \code{Dynamic} and accepts \code{Any} type. 

Structural constraints may be appended to this type as with any other type by using a new compound type (\sref{sec:compound-types}), where \code{Dynamic} is used as a trait type.\footnote{Thus, if \code{Dynamic} is used in a compound type, the compound type can contain a class type that is not \code{Dynamic}. This is different from \code{Any}, which can only appear as a class type.}

With respect to overloading resolution (\sref{sec:overloading-resolution}), this type is almost\footnote{The type annotation would have to 1:1 copy the runtime type to be the same specific, but no explicit type annotation can ever be more specific.} always the most specific, as it is replaced by the actual runtime type of the value it is assigned to. 

Typing an expression with this type triggers early evaluation, which is important to know if the expression is an argument expression and its corresponding parameter is lazily evaluated. 

If the \code{Dynamic} type is used as the type annotation of a parameter, it is translated to \code{Any} (plus additional structural constraints, if any present), and treated as \code{Dynamic} in the following code.

The \code{Dynamic} type is disallowed from use within type parameters, result types and conformance check expressions (\sref{sec:typed-expressions}). 

Using \code{Dynamic} type is one of possible ways to use multi-methods -- the type of arguments typed as \code{Dynamic} are bound at runtime, not during compilation. Moreover, the two approaches can be combined, as not every argument expression needs to be \code{Dynamic}.





\section{Relations Between Types}

We define two relations between types. 
\begin{quote}\begin{tabular}{l@{\gap}l@{\gap}l}
\em Type equivalence & $T \equiv U$ & $T$ and $U$ are interchangeable
in all contexts.
\\
\em Conformance & $T \conforms U$ & Type $T$ conforms to type $U$.
\end{tabular}\end{quote}






\subsection{Type Equivalence}

Equivalence ($\equiv$) between types is the smallest congruence, such that the following statements are true:

\begin{itemize}
\item
If $t$ is defined by a type alias ~\lstinline@type t := T@, then $t$ is equivalent to $T$. 

\item
If a path $p$ has a singleton type ~\lstinline@$q$.type@, then \lstinline@$p$.type $\equiv\ q$.type@. 

\item
Two compound types (\sref{sec:compound-types}) are equivalent, if the sequences of their components are pairwise equivalent, occur in the same order and their refinements are equivalent.

\item
Two constrained types (\sref{sec:constrained-types}) are equivalent, if their base types are equivalent and their constraint blocks read the same. 

\item
Two refinements (\sref{sec:compound-types} \& \sref{sec:refinements}) are equivalent, if they bind the same names and the modifiers, types and bounds of every declared entity are equivalent in both refinements. 

\item
Two method types (\sref{sec:method-types}) are equivalent, if they are {\em override-equivalent} (\sref{sec:method-signature}).

\item
Two polymorphic method types (\sref{sec:polymorphic-method-types}) are equivalent, if they have the same number of type parameters, the result types are equivalent as well as variances, lower and upper bounds of corresponding type parameters. 

\item
Two existential types (\sref{sec:existential-types}) are equivalent, if they have the same number of quantifiers and the quantified types as well as lower and upper bounds of corresponding quantifiers are equivalent. 

\item
Two type constructors (\sref{sec:type-constructors}) are equivalent, if they have the same number of type parameters, the result types are equivalent as well as variances, lower and upper bounds of corresponding type parameters. 

\item 
Two unions (\sref{sec:unions}) are equivalent, if they have the same number of member types and those types are pairwise equivalent. 

\item 
Two intersection types (\sref{sec:intersection-types}) are equivalent, if they have the same number of member types and those types are pairwise equivalent. 

\end{itemize}






\subsection{Conformance}
\label{sec:conformance}

The conformance relation $(\conforms)$ is the smallest transitive relation that satisfies the following conditions:

\begin{itemize}

  \item Conformance includes equivalence, therefore if $T \equiv U$, then \lstinline@$T \conforms U$@. 

  \item For every value type $T$, \lstinline!Undefined $\conforms$ Nothing $\conforms T \conforms$ Object $\conforms$ Any!. 
 
  \item For every type constructor $T$ with any number of type parameters, \lstinline!Undefined $\conforms$ Nothing $\conforms T \conforms$ Object $\conforms$ Any!. 

  \item A type variable $t$ conforms to its upper bound and its lower bound conforms to $t$. 

  \item A class type or a parameterized type conforms to any of its base types. 

  \item A class type or a parameterized type conforms to a union type, iff it conforms to at least one of the union's component types. 

  \item  A singleton type ~\lstinline!$p$.type!~ conforms to the type of the path $p$.

  \item A type projection ~\lstinline!$T$#$t$!~ conforms to ~\lstinline!$U$#$t$!~ if $T$ conforms to $U$. 

  \item A unit of measure type $t$ conforms to another unit of measure type $u$ if and only if $t \equiv u$ or $t$ extends $u$, where $us$ is an abstract unit of measure type. 

  \item A parameterized type ~\lstinline!$T$[$T_1 \commadots T_n$]!~ conforms to ~\lstinline!$T$[$U_1 \commadots U_n$]!~ if the following conditions hold for $i = 1 \commadots n$.
    \begin{itemize}
      \item If the $i^{\superth}$ type parameter of $T$ is declared covariant, then $T_i \conforms U_i$.
      \item If the $i^{\superth}$ type parameter of $T$ is declared contravariant, then $U_i \conforms T_i$.
      \item If the $i^{\superth}$ type parameter of $T$ is declared invariant (neither covariant nor contravariant), then $U_i \equiv T_i$.
      \item If the $i^{\superth}$ type parameter of $T$ is declared with a conformance restricting annotation, then that annotation of $T_i$ must conform to the corresponding annotation of $U_i$. 
    \end{itemize}
    
  \item A constant constructor $T$ of a variant type $U$ (\sref{sec:variant-types}) conforms to $U$. If $U$ is a parameterized variant type, $T$ still conforms to $U$, even though it itself is not parameterized. 
  
  \item A non-constant constructor $T$ of a variant type $U$ (\sref{sec:variant-types}) conforms to $U$. If $U$ is a parameterized variant type, then $T$ conforms to $U$ if $T$ seen as a parameterized type conforms to parameterized $U$\footnote{Quite obviously.}. 

  \item A unit of type $N$ conforms to unit of type $U$ if $N$ extends $U$ or if $N \equiv U$. 

  \item A parameterized type ~\lstinline!$T$[<$N_1 \commadots N_n$>]!~ conforms to ~\lstinline!$T$[<$U_1 \commadots U_n$>]!~ if the following conditions hold for $i = 1 \commadots n$.
    \begin{itemize}
      \item For the $i^{\superth}$ type parameter of $T$, $N_i \conforms U_i$.
    \end{itemize}

  \item A compound type ~\lstinline!$T_1$ with $\ldots$ and $T_n$!~ conforms to each of its component types $T_i$.
  
  \item Conformance of intersection types is defined in (\sref{sec:intersection-types}).

  \item A constrained type ~\lstinline!$T$ where $b$!~ conforms to $T$. A type ~\lstinline!$T$ where $b_1$!~ conforms to ~\lstinline!$T$ where $b_2$!, if any value $e$ that conforms ~\lstinline!$T$ where $b_1$!~ by being a member of $T$ and passing the test presented by $b_1$, also conforms to ~\lstinline!$T$ where $b_2$!~ by passing the test presented by $b_2$.\footnote{This conformance is only tested based on actual values being tested, not the types themselves.}

  \item If $T \conforms U_i$ for $i = 1 \commadots n$, and every binding $d$ of a type or value $x$ in $R$ exists a member binding of $x$ in $T$ which subsumes $d$, then $T$ conforms to the compound type ~\lstinline!$U_1$ with $\ldots$ and $U_n$!. 

  \item The existential type ~\lstinline!$T$ for some { $Q$ }!~ conforms to $U$, if its skolemization (\sref{sec:existential-types}) conforms to $U$. This also means that the $t'_i$ type variables have to fall in between $U$'s type parameter bounds. 

  \item The type $T$ conforms to the existential type ~\lstinline!$U$ for some { $Q$ }!~ if $T$ conforms to at least one of the type instances (\sref{sec:existential-types}) of ~\lstinline!$U$ for some { $Q$ }!. 

  \item If $T_i \equiv T'_i$ for $i = 1 \commadots n$ and $R \conforms R'$, then the method type ~\lstinline!($p_1$: $T_1 \commadots p_n$: $T_n$) $\mapsto\ R$!~ conforms to ~\lstinline!($p'_1$: $T'_1 \commadots p'_n$: $T'_n$) $\mapsto\ R'$!. 

  \item The polymorphic type or type constructor 
\begin{lstlisting}
[$\pm a_1$ >: $L_1$ <: $U_1 \commadots \pm a_n$ >: $L_n$ <: $U_n$] $\mapsto\ T$
\end{lstlisting}
conforms to the polymorphic type or type constructor 
\begin{lstlisting}
[$\pm a_1$ >: $L'_1$ <: $U'_1 \commadots \pm a_n$ >: $L'_n$ <: $U'_n$] $\mapsto\ T'$
\end{lstlisting}
if one has $T \conforms T'$, and $L_i \conforms L'_i$ and $U_i \conforms U'_i$ for $i = 1 \commadots n$. 

  \item Polymorphic types or type constructors $T$ and $T'$ must also fulfill the following. We characterize $T$ and $T'$ by their type parameter clauses ~\lstinline![$a_1 \commadots a_n$]!~ and ~\lstinline![$a'_1 \commadots a'_n$]!, where an $a_i$ or $a'_i$ may include a variance annotation, annotations, a higher-order type parameter clauses, and bounds. Then, $T$ conforms to $T'$ if any list ~\lstinline![$t_1 \commadots t_n$]!---with declared variances, annotations, bounds and higher-order type parameter clauses---of valid type arguments for $T'$ is also a valid list of type arguments for $T$ and ~\lstinline!$T$[$t_1 \commadots t_n$] <: $T'$[$t_1 \commadots t_n$]!. Note that this entails that:
  \begin{itemize}
    \item The bounds on $a_i$ must be the same or weaker than the corresponding bounds declared for $a'_i$. 
    \item The variance of $a_i$ must match the variance of $a'_i$, where covariance matches covariance, contravariance matches contravariance and any variance matches invariance. 
    \item If annotation of $a'_i$ restricts conformance (\sref{sec:annotations}), then the corresponding annotation of $a_i$ must conform to it. 
    \item Recursively, these restrictions apply to the corresponding higher-order type parameter clauses of $a_i$ and $a'_i$. 
  \end{itemize}

  \item A function type ~\lstinline!($T_1 \commadots T_n$) -> $R$!~ (name it $f$) conforms to a function type ~\lstinline!($T'_1 \commadots T'_m$) -> $R'$!~ (name it $f'$), if types of arguments that are applicable to $f'$ are also applicable to $f$ (\sref{sec:function-applications}), and if $R$ conforms to $R'$. This includes reordering of named arguments/parameters and handling of repeated/optional parameters, and also variances -- since although $f$ might be applied to whatever $f'$ might be applied to, $f'$ might not be applied to whatever $f$ might be applied to (and vice versa).

  \item Polymorphic function traits ~\lstinline!Function!~ and ~\lstinline!Partial_Function!~ follow the rules for conformance of function types, as defined above. The repeated parameter, optional parameters, named parameters and all capturing parameters are derived from their conformance restricting annotations (\sref{sec:annotations}). Note that optional parameters may not be expressed with function types in another than with an annotation. The rules may be inverted in the means of constructing a virtual methods $m$ and $m'$ that are reconstructed from the type arguments of the function types $f$ and $f'$ respectively, and applying the rules for function types on them.
 
  \item A union type (\sref{sec:unions}) $U_1$ conforms to $U_2$, if every member type that is present in $U_2$ has also an equivalent member type in $U_1$. $U_1$ may thus contain more member types than $U_2$, but must contain all of member types in $U_2$. See also: (\sref{sec:unions}).

  \item An overloaded type projection conforms to type of every overloaded alternative. 
\end{itemize}

A declaration or definition in some compound type of class type $C$ {\em subsumes} another declaration of the same name in some compound type or class type $C'$, if one of the following conditions holds. 
\begin{itemize}
  \item A value declaration or definition that defines a name $x$ with type $T$ subsumes a value or method declaration that defines $x$ with type $T'$, provided $T \conforms T'$. 
  \item A method declaration or definition that defines a name $x$ with type $T$ subsumes a method declaration that defines $x$ with type $T'$, provided $T \conforms T'$. 
  \item A type alias ~\lstinline!type $t$[$T_1 \commadots T_n$] = $T$!~ subsumes a type alias ~\lstinline!type $t$[$T_1 \commadots T_n$] = $T'$!~ if $T \equiv T'$. 
  \item A type declaration ~\lstinline!type $t$[$T_1 \commadots T_n$] >: $L$ <: $U$!~ subsumes a type declaration ~\lstinline!type $t$[$T_1 \commadots T_n$] >: $L'$ <: $U'$!, if $L' \conforms L$ and $U \conforms U'$. 
  \item A type or class definition that binds a type name $t$ subsumes an abstract type declaration ~\lstinline!type $t$[$T_1 \commadots T_n$] >: $L$ <: $U$!, if $L \conforms t \conforms U$. 
\end{itemize}

The ($\conforms$) relation forms partial order between types, i.e. it is transitive, antisymmetric and reflexive. The terms {\em least upper bound} and {\em greatest lower bound} of a set of types are understood to be relative to that order. 

\paragraph{Note}
The least upper bound or the greatest lower bound of a set of types does not always exist. Aml is free to reject a term which has a type specified as a least upper bound or a greatest lower bound, and that bound would be more complex than a preset limit, e.g. this could happen with infinite bounds sequence. 

The least upper bound or the greatest lower bound might also not be unique. If there are several such bounds, Aml is free to pick up any of them. 




\subsection{Least Upper Bound}
\label{sec:least-upper-bound}

The term {\em least upper bound} of a set of types (and the closely related term {\em weak least upper bound} of a set of types) have two possible representations. 

\begin{itemize}
  \item {\em Common supertype representation}. This approach selects one compound type that is a common supertype of all types in the set. 
  \item {\em Union type representation}. This approach simply makes a union type (\sref{sec:unions}) out of all types in the set. 
\end{itemize}

Aml implicitly uses the union type representation for least upper bounds. The union type already presents quite a few simplifications of itself. This behaviour can be changed per-scope, per-file or even per-module, using a pragma:
\begin{lstlisting}
pragma least-upper-bound(Union)  -- implicit
pragma least-upper-bound(Common) -- optionally
\end{lstlisting}
These pragmas are a part of Aml's \code{Language} module. % TBD: specify where these pragmas are exactly located





\subsection{Weak Conformance}
\label{sec:weak-conformance}

For now, {\em weak conformance} is a relation defined on members of the \code{Number} type as a relaxation of conformance, written as $S \conforms _w T$. The relation is simple: a type $t$ weakly conforms to another type $u$ when $u$'s size contains all values of $t$ (we say that $t$ can be converted to $u$ without precision loss). 

A {\em weak least upper bound} is a least upper bound with respect to weak conformance. 





\subsection{Type Consistency}
\label{sec:type-consistency}

Type consistency is a relation between types, and a part of Aml's {\em gradual typing}. 

Consistency ($\sim$) relation allows an implicit conversion between two types. By writing $T_1 \sim T_2$, we say that $T_1$ is consistent with $T_2$ and vice versa. We will denote the \code{Dynamic} type as $?$ (not to be confused with the existential type placeholder). 

\begin{itemize}
  \item For any type $T$, we have that $T \sim ?$ and also $? \sim T$. 
  \item For every type $T$, we have $T \sim T$. 
  \item A tuple type $(T_1, T_2)$ is consistent with another tuple type $(S_1, S_2)$ if $T_1 \sim S_1$ and $T_2 \sim S_2$, and so on for tuple types of any other arbitrary size. 
  \item A function type \lstinline!$P_1$ -> $R_1$! is consistent with another function type \lstinline!$P_2$ -> $R_2$! if $P_1 \sim P_2$ and $R_1 \sim R_2$. 
\end{itemize}

% TBD: if a rule is found missing from here, add it




\section{Reified Types}
\label{sec:reified-types}

Unlike in Java or Scala, {\em type erasure} does not exist in Aml. Instead, type arguments are {\em reified} -- meaning that they persist in runtime. This is achieved by generating a lightweight subtype of parameterized types, containing basically just a reference to the parameterized type and a tuple of type arguments. This also implies that each new combination of type arguments to the exact same parameterized type creates a new lightweight subtype.

Reified types have some major effects on programs in Aml:
\begin{itemize}

\item Type arguments are accessible in runtime. The actual type argument can be inspected via reflection. 

\item Type arguments do not go away after compilation. This means, for example, that mutable collections should have invariant type parameters, since a hypothetical \code{List[+T]} can have type instance \code{List[String]} assigned to a variable bound to be a \code{List[Object]}, but instances of other subclasses than those that conform to \code{String} will not be able to be added to the collection. This is in fact true even if Aml did have type erasure -- the difference is, with reified types, the addition of a new incompatible value will fail immediately, unlike with type erasure, where retrieving the added value would fail later. 
\end{itemize}





\section{Types Representing Emptiness}
\label{sec:emptiness}

In Aml, there are a few types and their values that represent emptiness of some sort. The following lists specifies their semantical purposes. 

\begin{enumerate}
  \item The \code{Nothing} type, which is the bottom type ($\bot$) of Aml's type system. 
  
  It's the only empty type in Aml, i.e. it has no type inhabitants. Aml defines a function that has this type: \code{undefined}, parameterless. 
  
  To signal that a function never returns, the type alias \code{Diverges} should be used instead, as its name better expresses the intent. 

  \item The \code{None} variant of the \code{Option[$T$]} variant type and represents a missing value.
  
  The dedicated keyword \code{nil} is the value of that type. 
  
  \item The \code{Unit} type. It is the only \code{Tuple} type with no type parameters and no data members. 
  
  It's semantical meaning is that no value is even expected. It is used for functions that should never return any meaningful value (but they do return control back to their users), and that are technically procedures, whose purpose lies in side-effects. 
  
  The type has just one inhabitant, the ``\code{()}'' value, also known as an empty tuple. In a Aml VM, this type is usually an immediate value.
  
  There are no implicit conversions from \code{Unit} to any other type defined by Aml. 
\end{enumerate}






