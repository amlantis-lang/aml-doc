%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\chapter{Syntax}
\label{ch:aml-base-syntax}

The syntax of \AmlBase is based on Lisp-1, the so-called ``S-expressions'' (shorter for ``symbolic expressions''\footnote{Which we will not abbreviate further as ``sexprs''.}) and blatantly borrowing from languages such as Scheme, Racket or Clojure, while maintaining similarities with the \Aml and \AmlCore languages. 




\section[The Aml/Base.Lang.Reader]{The \lstinline!Aml/Base.Lang.Reader!}
\label{sec:aml-base-lang-reader}




\subsection{Delimiters and Dispatch}
\label{subsec:aml-base-lang-reader-delimiters-dispatch}

Along with whitespace (as defined by Unicode ``White\_Space'' property), the following characters are delimiters:

\begin{lstlisting}
  ( ) [ ] { } " ' ` , ~ ;
\end{lstlisting}

The \lstinline@#@ character has got a special meaning, determined by the following character or characters; see below for details. 

After skipping whitespace, the \AmlBase reader dispatches based on the next character or characters in the source port this way:

\begin{table}
\begin{longtable}{ r l }
  \lstinline!(! & starts a pair or list; see \nameref{subsec:aml-base-lang-reader-lists}. \\
  \lstinline![! & starts a pair, list, or array; see \nameref{subsec:aml-base-lang-reader-lists}. \\
  \lstinline!{! & starts a record; see \nameref{subsec:aml-base-lang-reader-records}. \\
  \lstinline!)! & matches \lstinline!(! or raises error. \\
  \lstinline!]! & matches \lstinline![! or raises error. \\
  \lstinline!}! & matches \lstinline!{! or raises error. \\
  
\pagebreak[2]
  \lstinline!"! & starts a string; see \nameref{subsec:aml-base-lang-reader-strings}. \\
  \lstinline!'! & starts a quote or a type variable; see \nameref{subsec:aml-base-lang-reader-quotes}. \\
  \lstinline!,! & is ignored as whitespace. \\
  \lstinline!`! & starts a tag, a symbol or a quote; see \nameref{subsec:aml-base-lang-reader-polytags} and \nameref{subsec:aml-base-lang-reader-symbols}. \\
  \lstinline!~! & starts a label; see \nameref{subsec:aml-base-lang-reader-labels}. \\
  \lstinline!;! & starts a line comment; see \nameref{subsec:aml-base-lang-reader-comments}. \\
  
\pagebreak[2]
  \lstinline!#y! or \lstinline!#Y! & true; see \nameref{subsec:aml-base-lang-reader-booleans}. \\
  \lstinline!#n! or \lstinline!#N! & false; see \nameref{subsec:aml-base-lang-reader-booleans}. \\
  \lstinline!#t! or \lstinline!#T! & true; see \nameref{subsec:aml-base-lang-reader-booleans}. \\
  \lstinline!#f! or \lstinline!#F! & false; see \nameref{subsec:aml-base-lang-reader-booleans}. \\  
  
  \lstinline!#(! & starts a set; see \nameref{subsec:aml-base-lang-reader-sets}. \\
  \lstinline!#[! & starts a vector; see \nameref{subsec:aml-base-lang-reader-vectors}. \\
  \lstinline!#{! & starts a map; see \nameref{subsec:aml-base-lang-reader-maps}. \\
  
\pagebreak[2]
  \lstinline!#\! & starts a character; see \nameref{subsec:aml-base-lang-reader-characters}. \\
  \lstinline!#"! & starts a byte string; see \nameref{subsec:aml-base-lang-reader-strings}. \\
  \lstinline!#~! & starts a symbol; see \nameref{subsec:aml-base-lang-reader-symbols}. \\
  \lstinline!#:! & starts a keyword; see \nameref{subsec:aml-base-lang-reader-keywords}. \\
  \lstinline!#'! & starts a quote; see \nameref{subsec:aml-base-lang-reader-quotes}. \\
  \lstinline!#`! & starts a quasi-quote; see \nameref{subsec:aml-base-lang-reader-quotes}. \\
  \lstinline!#,! & starts a (possibly splicing) unquote; see \nameref{subsec:aml-base-lang-reader-quotes}. \\
  \lstinline!#s'! & starts a syntax quote; see \nameref{subsec:aml-base-lang-reader-quotes}. \\
  \lstinline!#s`! & starts a syntax quasi-quote; see \nameref{subsec:aml-base-lang-reader-quotes}. \\
  \lstinline!#s,! & starts a syntax (possibly splicing) unquote; see \nameref{subsec:aml-base-lang-reader-quotes}. \\
  \lstinline!#^! & starts a metadata; see \nameref{subsec:aml-base-lang-reader-metadata}. \\
  \lstinline!##! & starts a parameterized read; see \nameref{subsec:aml-base-lang-reader-parameterized-reads}. \\
  
\pagebreak[2]
  \lstinline!#e! or \lstinline!#E! & starts a number; see \nameref{subsec:aml-base-lang-reader-numbers}. \\
  \lstinline!#i! or \lstinline!#I! & starts a number; see \nameref{subsec:aml-base-lang-reader-numbers}. \\
  
  \lstinline!#<<! & starts a string; see \nameref{subsec:aml-base-lang-reader-strings}. \\
  
  \lstinline!#|! & starts a block comment; see \nameref{subsec:aml-base-lang-reader-comments}. \\
  \lstinline!#;! or \lstinline!#_! & starts an S-expression comment; see \nameref{subsec:aml-base-lang-reader-comments}. \\
  ``\lstinline@#! @'' & starts a line comment; note that the space is necessary; see \nameref{subsec:aml-base-lang-reader-comments}. \\
  \lstinline@#!/@ & starts a line comment; see \nameref{subsec:aml-base-lang-reader-comments}. \\
  
\pagebreak[2]
  \lstinline@#!@ & may start a reader extension use; see \nameref{subsec:aml-base-lang-reader-extension}. \\
  \lstinline!#reader! & starts a reader extension use; see \nameref{subsec:aml-base-lang-reader-extension}. \\
  \lstinline!#lang! & starts a reader extension use; see \nameref{subsec:aml-base-lang-reader-extension}. \\
  
  \lstinline!#$other$! & starts a handler defined in current readtable or raises error. \\
  
  {\em otherwise} & starts a symbol; see \nameref{subsec:aml-base-lang-reader-symbols}. \\
\end{longtable}
\caption{\label{tab:aml-base-lang-reader-dispatch}Table of Dispatches recognized by \lstinline!Aml/Base.Lang.Reader!.}
\end{table}





\newpage

\subsection{Reading Symbols}
\label{subsec:aml-base-lang-reader-symbols}

A sequence of source characters that does not start with any of the sequences defined in \nameref{subsec:aml-base-lang-reader-delimiters-dispatch} is parsed as either a symbol or a number. The sequence ``\lstinline!#~!''\footnote{We have decided to use ``\lstinline!#~!'' instead of ``\lstinline!#\%!'' for symbols as the resulting symbol appears easier to read.} also starts a symbol. A successful number parse takes precedence over symbol parse, see \nameref{subsec:aml-base-lang-reader-numbers}. 

A sequence of source characters that starts with ``\lstinline!``!'' is parsed as a symbol until a matching ``\lstinline!``!'' is found. If a ``\lstinline!``!'' should appear inside the symbol, it has to be preceded by a ``\lstinline!\!'', and that character is the only character omitted from the resulting symbol.\footnote{This is why quasiquote must not be followed by another backtick.}

A symbol parse may continue with ``\lstinline!#!'' without dispatching on it, since the form does not start with it, and becoming a part of the symbol parse.

Symbols that consist entirely of ``operator'' characters (Unicode character classes Sm, So, except for \lstinline!U+0060!) are treated specially, TBD\footnote{This is yet to be properly defined, but generally a property will be added to the form marking it ``operator''.}.

\example A few examples of parsing a symbol:

\begin{tabular}{ r l }
  \lstinline!Plum! & reads equal to \lstinline!(string->symbol "Plum")! \\
  \lstinline!Plu#m! & reads equal to \lstinline!(string->symbol "Plu#m")! \\
  \lstinline!Pl.um! & reads equal to \lstinline!(string->symbol "Pl.um")! \\
  \lstinline!#~Plum! & reads equal to \lstinline!(string->symbol "#~Plum")! \\
  \lstinline!string->symbol! & reads equal to \lstinline!(string->symbol "string->symbol")! \\
  \lstinline!``a long symbol``! & reads equal to \lstinline!(string->symbol "a long symbol")! \\
  \lstinline!``this \`` is included``! & reads equal to \lstinline!(string->symbol "this `` is included")! \\
\end{tabular}




\subsection{Reading Numbers}
\label{subsec:aml-base-lang-reader-numbers}

A sequence of source characters that does not start with any of the sequences defined in \nameref{subsec:aml-base-lang-reader-delimiters-dispatch} is parsed as a number when it matches the following grammar, in which $n$ is a variable.

A number is optionally prefixed by an exactness specifying form, case-insensitively, \lstinline!#e! (exact) or \lstinline!#i! (inexact), which specifies its parsing as an exact or inexact number. Such form can be followed by whitespace, which is simply ignored.

% TODO: add specification for number exactness

In the grammar below, each literal lowercase letter stands for both itself and its uppercase form.

\grammar
\begin{longtable}{ r l }
  ‹$number_n$› & \lstinline!::=! ‹$prefix_n$› ‹$exact_n$› | ‹$inexact_n$› \\
  
  ‹$exact_n$› & \lstinline!::=! ‹$exact$-$rational_n$› | ‹$exact$-$complex_n$› \\
  ‹$exact$-$rational_n$› & \lstinline!::=! ‹$sign$›\textsubscript{opt} ‹$unsigned$-$rational_n$› \\
  ‹$unsigned$-$rational_n$› & \lstinline!::=! ‹$unsigned$-$integer_n$› \\
  \nopagebreak[3] & \lstinline! | ! ‹$unsigned$-$integer_n$› ``\lstinline!/!'' ‹$unsigned$-$integer_n$› \\
  
\pagebreak 
  ‹$exact$-$integer_n$› & \lstinline!::=! ‹$sign$›\textsubscript{opt} ‹$unsigned$-$integer_n$› \\
  ‹$unsigned$-$integer_n$› & \lstinline!::=! ‹$digits_n$›\textsuperscript{+} \\
  
  ‹$exact$-$complex_n$› & \lstinline!::=! ‹$exact$-$rational_n$›\textsubscript{opt} ‹$sign$› ‹$unsigned$-$rational_n$› ``\lstinline!i!'' \\
    
\pagebreak[3] 
  ‹$inexact_n$› & \lstinline!::=! ‹$inexact$-$real_n$› | ‹$inexact$-$complex_n$› \\
  ‹$inexact$-$real_n$› & \lstinline!::=! ‹$sign$›\textsubscript{opt} ‹$inexact$-$simple_n$› (‹$exp_n$› ‹$exact$-$integer_n$›)\textsubscript{opt} \\
  ‹$inexact$-$unsigned_n$› & \lstinline!::=! ‹$inexact$-$simple_n$› \\
  ‹$inexact$-$simple_n$› & \lstinline!::=! ‹$digits_n$› ``\lstinline!.!'' ‹$digits_n$› \\
  \nopagebreak[3] & \lstinline! | ! ‹$digits_n$› ``\lstinline!/!'' ‹$digits_n$› \\
    
  ‹$inexact$-$complex_n$› & \lstinline!::=! ‹$inexact$-$real_n$›\textsubscript{opt} ‹$sign$› ‹$inexact$-$unsigned_n$› ``\lstinline!i!'' \\
  
  ‹$sign$› & \lstinline!::=! ``\lstinline!+!'' | ``\lstinline!-!'' \\
  
\pagebreak[3] 
  ‹$general$-$number_n$› & ‹$exactness$›\textsubscript{opt} ‹$number_n$› \\
  ‹$exactness$› & \lstinline!::=! ``\lstinline!#e!'' | ``\lstinline!#i!'' \\
\end{longtable}

In the table below, we define the parameterized $digits_n$, $exp_n$ and $prefix_n$ for all supported $n$s.

\grammar
\begin{longtable}{ r l }
  % hexadecimal
  ‹$digit_{16}$› & \lstinline!::=! ‹$digit_{12}$› | ``\lstinline!c!'' | ``\lstinline!d!'' | ``\lstinline!e!'' | ``\lstinline!f!'' \\
  ‹$prefix_{16}$› & \lstinline!::=! ``\lstinline!0x!'' \\
  
  % duodecimal
  ‹$digit_{12}$› & \lstinline!::=! ‹$digit_{10}$› | ``\lstinline!a!'' | ``\lstinline!b!'' \\
  ‹$prefix_{12}$› & \lstinline!::=! ``\lstinline!0d!'' \\
  
  % decimal
  ‹$digit_{10}$› & \lstinline!::=! ‹$digit_8$› | ``\lstinline!8!'' | ``\lstinline!9!'' \\
  ‹$prefix_{10}$› & \lstinline!::=! empty sequence \\
  
  % octal
  ‹$digit_8$› & \lstinline!::=! ‹$digit_2$› | ``\lstinline!2!'' | ``\lstinline!3!'' | ``\lstinline!4!'' | ``\lstinline!5!'' | ``\lstinline!6!'' | ``\lstinline!7!'' \\
  ‹$prefix_8$› & \lstinline!::=! ``\lstinline!0o!'' \\
  
  % binary
  ‹$digit_2$› & \lstinline!::=! ``\lstinline!0!'' | ``\lstinline!1!'' \\
  ‹$prefix_2$› & \lstinline!::=! ``\lstinline!0b!'' \\
  
  ‹$exp_{16}$› & \lstinline!::=! ``\lstinline!p!'' \\
  ‹$exp_{12}$› & \lstinline!::=! ‹$exp_{10}$› \\
  ‹$exp_{10}$› & \lstinline!::=! ``\lstinline!e!'' \\
  ‹$exp_8$› & \lstinline!::=! ‹$exp_{10}$› \\
  ‹$exp_2$› & \lstinline!::=! ‹$exp_{10}$› \\
  
  ‹$digits_n$› & \lstinline!::=! ‹$digit_n$› (``\lstinline!_!''\textsubscript{opt} ‹$digit_n$›)\textsuperscript{*} \\
\end{longtable}

In the grammar below, we define the special case of sexagesimal numbers. Some of the rules here override those for non-sexagesimal numbers.

\grammar
\begin{longtable}{ r l }
  % sexagesimal
  ‹$digit_{60}$› & \lstinline!::=! (``\lstinline!0!'' | ``\lstinline!1!'' | ``\lstinline!2!'' | ``\lstinline!3!'' | ``\lstinline!4!'' | ``\lstinline!5!'')\textsubscript{opt} ‹$digit_{10}$› \\
  ‹$prefix_{60}$› & \lstinline!::=! ``\lstinline!0s!'' \\
  ‹$exp_{60}$› & \lstinline!::=! ‹$exp_{10}$› \\
  
  ‹$digits_{60}$› & \lstinline!::=! ‹$digit_{60}$› (``\lstinline!,!'' ‹$digit_{60}$›)\textsuperscript{*} \\
  ‹$inexact$-$simple_{60}$› & \lstinline!::=! ‹$digits_{60}$› ``\lstinline!;!'' ‹$digits_{60}$› \\
\end{longtable}

% TODO: add examples of number parses





\subsection{Reading Booleans}
\label{subsec:aml-base-lang-reader-booleans}

The forms ``\lstinline!#yes!'', ``\lstinline!#y!'', ``\lstinline!#true!'', ``\lstinline!#t!'' (case-insensitive) followed by a delimiter are the complete input syntax for the \lstinline!System.Boolean.Yes! constant, and ``\lstinline!#no!'', ``\lstinline!#n!'', ``\lstinline!#false!'', ``\lstinline!#f!'' (case-insensitive) followed by a delimiter are the complete input syntax for the \lstinline!System.Boolean.No! constant.





\subsection{Reading Pairs, Lists \& Arrays}
\label{subsec:aml-base-lang-reader-lists}

Sequences of input characters that start with ``\lstinline!(!'' or ``\lstinline![!'' begin parsing characters to form a pair or a list.\footnote{Note that in Lisp languages, not excluding \AmlBase, evaluating list forms does not necessarily produce a list - instead, many list forms are a function application form. To get a list data structure, one either needs to construct it with function applications, or quote the list form.}

Parsing a pair or list form entails recursively parsing sub-forms until a matching ``\lstinline!(!'' or ``\lstinline![!'' (respectively, these are not interchangeable) is found. A delimited ``\lstinline!.!'' is handled specially.

If there is no delimited ``\lstinline!.!'' among the forms between parentheses, then a list is formed, containing the results of the recursive reads, in the same order as they appear in the source text.

If there is exactly one delimited ``\lstinline!.!'', it's not the first and also not the last sub-form, and there are two other sub-forms (the first and the last one), then a pair is formed. More generally, if there are more sub-forms before the delimited ``\lstinline!.!'', a pair is formed with the last of them, and recursively, a pair is formed with the preceding sub-form and the previously formed pair, thus forming nested pairs.

If there are exactly two delimited ``\lstinline!.!'', none of which is the first and the last sub-form, and there is at least one other sub-form in between them, then the middle sub-form is put first in the resulting list, then the sub-forms before the first delimited ``\lstinline!.!'', and finally the sub-forms after the second delimited ``\lstinline!.!''. 

If the sequences of input characters start with ``\lstinline![|!'' and end with ``\lstinline!|]!'', then an array is formed instead of a list.

% TODO: specify that lists that use [ and ] have a property attached to their syntax object, or wrapped in a pair with a symbol representing the parentheses shape

\example A few examples of parsing lists, pairs and arrays:

\begin{tabular}{ r l }
  \lstinline!()! & reads equal to \lstinline!(list)! \\
  \lstinline!(1 2 3)! & reads equal to \lstinline!(list 1 2 3)! \\
  \lstinline![1 2 3]! & reads equal to \lstinline!(list 1 2 3)! \\
  \lstinline![|1 2 3|]! & reads equal to \lstinline!(array 1 2 3)! \\
  \lstinline!(1 2 (3))! & reads equal to \lstinline!(list 1 2 (list 3))! \\
  \lstinline!(1 . 2)! & reads equal to \lstinline!(pair 1 2)! \\
  \lstinline!(1 2 3 . 4)! & reads equal to \lstinline!(pair 1 (pair 2 (pair 3 4)))! \\
  \lstinline!(1 2 . ())! & reads equal to \lstinline!(pair 1 (pair 2 (list)))! \\
  \lstinline!(1 . 2 . 3)! & reads equal to \lstinline!(list 2 1 3)! \\
\end{tabular}







\subsection{Reading Records}
\label{subsec:aml-base-lang-reader-records}

Sequences of input characters that start with ``\lstinline!{!'' begin parsing characters to form a record.

Parsing a record entails recursively parsing sub-forms, until a matching ``\lstinline!}!'' is found. 

There are 3 different possible ordering of sub-forms:
\begin{itemize}
  \item Pairs of sub-forms, where first item is a record field, second is any form.
  \item First sub-form is any form, followed by keyword ``\lstinline!#:with!'', followed by pairs of sub-forms, where first item is a record field, second is any form. This sequence of sub-forms can then optionally be followed by a keyword ``\lstinline!#:without!'', followed by record field sub-forms.
  \item First sub-form is any form, followed by keyword ``\lstinline!#:without!'', followed by record field sub-forms.
\end{itemize}

A record field is such a form $f$ for which ``\lstinline!(record-field-name? $f$)!'' returns ``\lstinline!#yes!''.\footnote{Record fields are usually symbols, in case of ambiguities, such symbol may refer to a fully or partially qualified record field.}

If the sequence of input characters start with ``\lstinline!{|!'' and end with ``\lstinline!|}!'', then an anonymous record is formed instead of a (regular) record.

\example A few examples of parsing records:

\begin{lstlisting}
 { Fraction.numerator 17 denominator 3 }
 { fr #:with numerator 16 }
 { fr #:with numerator 16 #:without denominator }
 { fr #:without denominator }
\end{lstlisting}






\subsection{Reading Strings}
\label{subsec:aml-base-lang-reader-strings}

Sequences of input characters that start with ``\lstinline!"!'' begin parsing characters to form a string, until another ``\lstinline!"!'' is found (that is not escaped by a single ``\lstinline!\!''). % TODO: add link to spec of strings

Within a string sequence, the following ``escape sequences'' are recognized:

\begin{itemize}
  \item ``\lstinline!\'!'': single quote
  \item ``\lstinline!\"!'': double-quotes (does not terminate the string form)
  \item ``\lstinline!\\!'': backslash (the second is not an escaping backslash)
  \item ``\lstinline!\0!'': binary zero (NUL, \lstinline!U+0000!)
  \item ``\lstinline!\a!'': BEL (alarm) character (\lstinline!U+0007!)
  \item ``\lstinline!\b!'': backspace (\lstinline!U+0008!)
  \item ``\lstinline!\e!'': escape (\lstinline!U+001B!)
  \item ``\lstinline!\f!'': form feed (\lstinline!U+000C!)
  \item ``\lstinline!\n!'': end-of-line (\lstinline!U+000A!)
  \item ``\lstinline!\r!'': carriage return (\lstinline!U+000D!)
  \item ``\lstinline!\t!'': horizontal tab (character tabulation, \lstinline!U+0009!)
  \item ``\lstinline!\v!'': vertical tab (line tabulation, \lstinline!U+000B!)
  
  \item ``\lstinline!\x$nn$!'': Unicode for the hexadecimal number specified by $nn$, where each $n$ is a~‹$digit_{16}$›.
  \item ``\lstinline!\u$nnnn$!'': Unicode for the hexadecimal number specified by $nnnn$, where each $n$ is a~‹$digit_{16}$›, the character \lstinline!U+$nnnn$!.
  \item ``\lstinline!\U$nnnnnnnn$!'': Unicode for the hexadecimal number specified by $nnnnnnnn$, where each $n$ is a~‹$digit_{16}$›, the character \lstinline!U+$nnnnnnnn$!.
  
  \item ``\lstinline!\u{$n_1 \ldots n_m$}!'': Unicode for the hexadecimal number specified by $n_1 \ldots n_m$, where each $n_i$ is a~‹$digit_{16}$› and $m < 8$, the character \lstinline!U+$n_1 \ldots n_m$!.
  
  % TODO: add "named unicode character and named character entity: \&nbsp; and \{AMPERSAND}
  
  \item ``\lstinline!\!‹$newline$›'': elided, where ‹$newline$› is either an end-of-line, carriage return, or carriage return end-of-line combination. This sequence is not added to the string form.
\end{itemize}

When the sequence of input characters starts with ``\lstinline!#"!'' instead of just ``\lstinline!"!'', the parsed string form is a byte string. % TODO: add link to spec of byte strings

Sequences of input characters that start with ``\lstinline!#<<!'' begin parsing characters to form a string, in this form called {\em here string}. The characters following ``\lstinline!#<<!'' until a newline character define a terminator for the string. The content of the resulting string form includes all characters between the line containing ``\lstinline!#<<!'' and a line whose entire content is the specified terminator (possibly preceded by whitespace). The first and last line of such form are not included in the resulting string form. No escape sequences are recognized in {\em here strings}. % TODO: Aml/Core and Aml may support more versions of here strings, including code interpolation





\subsection{Reading Characters}
\label{subsec:aml-base-lang-reader-characters}

Sequences of input characters that start with ``\lstinline!#\!'' begin parsing characters to form a character constant. The following forms are recognized:

\begin{itemize}
  \item ``\lstinline!#\nul!'', ``\lstinline!#\null!'' or ``\lstinline!#\0!'': NUL (ASCII 0), the next character must not be alphabetic.
  \item ``\lstinline!#\backspace!'': backspace (\lstinline!U+0008!), the next character must not be alphabetic.
  \item ``\lstinline!#\tab!'' or ``\lstinline!#\htab!'': horizontal tab (\lstinline!U+0009!), the next character must not be alphabetic.
  \item ``\lstinline!#\newline!'' or ``\lstinline!#\linefeed!'': end-of-line (\lstinline!U+000A!), the next character must not be alphabetic.
  \item ``\lstinline!#\vtab!'': vertical tab (\lstinline!U+000B!), the next character must not be alphabetic.
  \item ``\lstinline!#\page!'': form feed (page break, \lstinline!U+000C!), the next character must not be alphabetic.
  \item ``\lstinline[deletekeywords={return}]!#\return!'': carriage return (\lstinline!U+000D!), the next character must not be alphabetic.
  \item ``\lstinline!#\space!'': space (\lstinline!U+0020!), the next character must not be alphabetic.
  \item ``\lstinline!#\delete!'' or ``\lstinline!#\rubout!'': delete (\lstinline!U+007F!), the next character must not be alphabetic.
  \item ``\lstinline!#\quote!'', ``\lstinline!#\squote!'' or ``\lstinline!#\'''!'': single quote (apostrophe, \lstinline!U+0027!), the next character must not be alphabetic after the former two forms.

  \item ``\lstinline!#\x$nn$!'': Unicode for the hexadecimal number specified by $nn$, where each $n$ is a~‹$digit_{16}$›.
  \item ``\lstinline!#\u$nnnn$!'': Unicode for the hexadecimal number specified by $nnnn$, where each $n$ is a~‹$digit_{16}$›, the character \lstinline!U+$nnnn$!.
  \item ``\lstinline!#\U$nnnnnnnn$!'': Unicode for the hexadecimal number specified by $nnnnnnnn$, where each $n$ is a~‹$digit_{16}$›, the character \lstinline!U+$nnnnnnnn$!.
  
  \item ``\lstinline!#\u{$n_1 \ldots n_m$}!'': Unicode for the hexadecimal number specified by $n_1 \ldots n_m$, where each $n_i$ is a~‹$digit_{16}$› and $m < 8$, the character \lstinline!U+$n_1 \ldots n_m$!.
  
  \item ``\lstinline!#\'$c$'!'': the character $c$, which must be a single Unicode codepoint.
\end{itemize}




\subsection{Reading Quotes}
\label{subsec:aml-base-lang-reader-quotes}

Upon reading a ``\lstinline!'!'', the reader recursively reads next form. If that form is a symbol, a type variable is formed. Otherwise, a new list is formed containing the symbol ``\lstinline!#'quote!'' and the following form. 

The reader recognizes a few other forms in the same way:

\begin{tabular}{ l l }
  \lstinline!'! & adds \lstinline!#'quote! if the following form is not a symbol \\
  \lstinline!`! & adds \lstinline!#'quasiquote! if not followed by ``\lstinline!`!'' and the next form is not a symbol \\
  \lstinline!#'! & adds \lstinline!#'quote! (always) \\
  \lstinline!#`! & adds \lstinline!#'quasiquote! \\
  \lstinline!#,! & adds \lstinline!#'unquote! \\
  \lstinline!#,@! & adds \lstinline!#'unquote-splicing! \\
  \lstinline!#s'! & adds \lstinline!#'syntax-quote! \\
  \lstinline!#s`! & adds \lstinline!#'syntax-quasiquote! \\
  \lstinline!#s,! & adds \lstinline!#'syntax-unquote! \\
  \lstinline!#s,@! & adds \lstinline!#'syntax-unquote-splicing! \\
\end{tabular}

\example A few examples of parsing quotes:

\begin{tabular}{ r l }
  \lstinline!'(apple)! & reads equal to \lstinline!(list #'quote #'apple)! \\
  \lstinline!#`(1 #,2)! & reads equal to \lstinline!(list #'quasiquote (list 1 (list #'unquote 2)))! \\
\end{tabular}





\subsection{Reading Comments}
\label{subsec:aml-base-lang-reader-comments}

A ``\lstinline!;!'' starts a line comment. When the reader encounters it, it discards all characters following it until the next new line. 

A ``\lstinline!#|!'' starts a nestable block comment. When the reader encounters it, it discards all characters following it until a closing   ``\lstinline!|#!''. When discarding characters within the nestable block comment, another ``\lstinline!#|!'' begins recursive discarding, so that pairs of matching ``\lstinline!#|!'' and ``\lstinline!|#!'' can be nested (hence nestable block comments). 

A ``\lstinline!#;!'' or a ``\lstinline!#_!'' starts an S-expression comment. When the reader encounters it, it recursively reads one following form, and discards it.

A ``\lstinline@#! @'' (a ``\lstinline@#!@'' followed by a whitespace) or ``\lstinline@#!/@'' starts a line comment, much like ``\lstinline!;!'' does, except if the line ends with ``\lstinline!\!'', the discarding continues to the next line. 

\example A few examples of comments:

\begin{tabular}{ l l }
  \lstinline!; comment! & reads equal to \textit{nothing} \\
  \lstinline!#| a |# 1! & reads equal to \lstinline!1! \\
  \lstinline!#| #| a |# 1 |# 2! & reads equal to \lstinline!2! \\
  \lstinline!#_1 2! & reads equal to \lstinline!2! \\
  \lstinline@#!/usr/bin/env amlc@ & reads equal to \textit{nothing} \\
  \lstinline@#! /usr/bin/env amlc@ & reads equal to \textit{nothing} \\
\end{tabular}






\subsection{Reading Vectors}
\label{subsec:aml-base-lang-reader-vectors}





\subsection{Reading Sets}
\label{subsec:aml-base-lang-reader-sets}





\subsection{Reading Maps}
\label{subsec:aml-base-lang-reader-maps}





\subsection{Reading Keywords}
\label{subsec:aml-base-lang-reader-keywords}

The sequence ``\lstinline!#:!'' starts a keyword. The parsing is the same as for a symbol preceded by ``\lstinline!#~!'', except for this initial sequence, and the part after this initial sequence is never parsed as a number. 

\example A few examples of parsing a keyword:

\begin{tabular}{ r l }
  \lstinline!#:Plum! & reads equal to \lstinline!(string->keyword "Plum")! \\
  \lstinline!#:42! & reads equal to \lstinline!(string->keyword "42")! \\
\end{tabular}







\subsection{Reading Polymorphic Tags}
\label{subsec:aml-base-lang-reader-polytags}





\subsection{Reading Labels}
\label{subsec:aml-base-lang-reader-labels}





\subsection{Reading Metadata}
\label{subsec:aml-base-lang-reader-metadata}





\subsection{Reading Parameterized Reads}
\label{subsec:aml-base-lang-reader-parameterized-reads}





\subsection{Reading via an Extension}
\label{subsec:aml-base-lang-reader-extension}

When the reader dispatches on the \lstinline!#reader! form, it recursively applies another reader to the current source port. 

% TODO: there is more supposed to be happening before a switch to another reader is made, like, consulting the current reader guard

First, the reader recursively reads the next datum after \lstinline!#reader!, and uses it as path to the another reader. Such reader is then loaded, and \lstinline!read! is used when this reader is in \lstinline!read! mode, or else, \lstinline!read-syntax! is used when this reader is in \lstinline!read-syntax! mode.

The \lstinline!#lang! reader form is similar. It must be followed by a single whitespace character (preferably a single space, ASCII 32), and then followed by an identifier form. The complete form is then terminated by a new line, or end-of-file. A sequence \lstinline!#lang $name$! is equivalent to \lstinline!#reader $name$.Lang.Reader!. 

% TODO: allow arguments for the readers? 

For compatibility with e.g. R\textsuperscript{6}RS, \lstinline@#!@ is an alias for \lstinline!#lang! followed by a space when it is followed by alphanumeric ASCII, \lstinline!+!, \lstinline!-! or \lstinline!_!. 





\subsubsection{S-Expression Reader Language}

\begin{lstlisting}
#lang s-exp $path$
\end{lstlisting}





\subsubsection{Chaining Reader Language}

\begin{lstlisting}
#lang reader $path$
\end{lstlisting}






